// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for prints and assertions.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

module Queue1_prediction(
  input                                                                                                      clock,
                                                                                                             reset,
  output                                                                                                     io_enq_ready,
  input                                                                                                      io_enq_valid,
  input  struct packed {logic hit; logic [31:0] target; logic [2:0] br_type; logic [15:0] GHR; logic T_NT; } io_enq_bits,
  input                                                                                                      io_deq_ready,
  output                                                                                                     io_deq_valid,
  output struct packed {logic hit; logic [31:0] target; logic [2:0] br_type; logic [15:0] GHR; logic T_NT; } io_deq_bits,
  output                                                                                                     io_count,
  input                                                                                                      io_flush
);

  reg  [52:0] ram;
  wire
    struct packed {logic hit; logic [31:0] target; logic [2:0] br_type; logic [15:0] GHR; logic T_NT; }
    ram_io_deq_bits_MPORT_data = /*cast(bit)*/ram;
  reg         full;
  wire        _GEN = io_enq_valid | full;
  wire        do_enq = ~(~full & io_deq_ready) & ~full & io_enq_valid;
  always @(posedge clock) begin
    if (do_enq) begin
      automatic
        struct packed {logic hit; logic target; logic br_type; logic GHR; logic T_NT; }
        _GEN_0 = /*cast(bit)*/5'h0;
      automatic
        struct packed {logic hit; logic [31:0] target; logic [2:0] br_type; logic [15:0] GHR; logic T_NT; }
        _GEN_1 = /*cast(bit)*/53'h0;
      automatic logic        _GEN_2 = do_enq | _GEN_0.target;
      automatic logic        _GEN_3 = do_enq | _GEN_0.br_type;
      automatic logic        _GEN_4 = do_enq | _GEN_0.GHR;
      automatic logic [31:0] _GEN_5 = do_enq ? io_enq_bits.target : _GEN_1.target;
      automatic logic [2:0]  _GEN_6 = do_enq ? io_enq_bits.br_type : _GEN_1.br_type;
      automatic logic [15:0] _GEN_7 = do_enq ? io_enq_bits.GHR : _GEN_1.GHR;
      ram <=
        {do_enq | _GEN_0.T_NT ? (do_enq ? io_enq_bits.T_NT : _GEN_1.T_NT) : ram[52],
         _GEN_4 ? _GEN_7[15] : ram[51],
         _GEN_4 ? _GEN_7[14] : ram[50],
         _GEN_4 ? _GEN_7[13] : ram[49],
         _GEN_4 ? _GEN_7[12] : ram[48],
         _GEN_4 ? _GEN_7[11] : ram[47],
         _GEN_4 ? _GEN_7[10] : ram[46],
         _GEN_4 ? _GEN_7[9] : ram[45],
         _GEN_4 ? _GEN_7[8] : ram[44],
         _GEN_4 ? _GEN_7[7] : ram[43],
         _GEN_4 ? _GEN_7[6] : ram[42],
         _GEN_4 ? _GEN_7[5] : ram[41],
         _GEN_4 ? _GEN_7[4] : ram[40],
         _GEN_4 ? _GEN_7[3] : ram[39],
         _GEN_4 ? _GEN_7[2] : ram[38],
         _GEN_4 ? _GEN_7[1] : ram[37],
         _GEN_4 ? _GEN_7[0] : ram[36],
         _GEN_3 ? _GEN_6[2] : ram[35],
         _GEN_3 ? _GEN_6[1] : ram[34],
         _GEN_3 ? _GEN_6[0] : ram[33],
         _GEN_2 ? _GEN_5[31] : ram[32],
         _GEN_2 ? _GEN_5[30] : ram[31],
         _GEN_2 ? _GEN_5[29] : ram[30],
         _GEN_2 ? _GEN_5[28] : ram[29],
         _GEN_2 ? _GEN_5[27] : ram[28],
         _GEN_2 ? _GEN_5[26] : ram[27],
         _GEN_2 ? _GEN_5[25] : ram[26],
         _GEN_2 ? _GEN_5[24] : ram[25],
         _GEN_2 ? _GEN_5[23] : ram[24],
         _GEN_2 ? _GEN_5[22] : ram[23],
         _GEN_2 ? _GEN_5[21] : ram[22],
         _GEN_2 ? _GEN_5[20] : ram[21],
         _GEN_2 ? _GEN_5[19] : ram[20],
         _GEN_2 ? _GEN_5[18] : ram[19],
         _GEN_2 ? _GEN_5[17] : ram[18],
         _GEN_2 ? _GEN_5[16] : ram[17],
         _GEN_2 ? _GEN_5[15] : ram[16],
         _GEN_2 ? _GEN_5[14] : ram[15],
         _GEN_2 ? _GEN_5[13] : ram[14],
         _GEN_2 ? _GEN_5[12] : ram[13],
         _GEN_2 ? _GEN_5[11] : ram[12],
         _GEN_2 ? _GEN_5[10] : ram[11],
         _GEN_2 ? _GEN_5[9] : ram[10],
         _GEN_2 ? _GEN_5[8] : ram[9],
         _GEN_2 ? _GEN_5[7] : ram[8],
         _GEN_2 ? _GEN_5[6] : ram[7],
         _GEN_2 ? _GEN_5[5] : ram[6],
         _GEN_2 ? _GEN_5[4] : ram[5],
         _GEN_2 ? _GEN_5[3] : ram[4],
         _GEN_2 ? _GEN_5[2] : ram[3],
         _GEN_2 ? _GEN_5[1] : ram[2],
         _GEN_2 ? _GEN_5[0] : ram[1],
         do_enq | _GEN_0.hit ? (do_enq ? io_enq_bits.hit : _GEN_1.hit) : ram[0]};
    end
    if (reset)
      full <= 1'h0;
    else
      full <= ~io_flush & (do_enq == (full & io_deq_ready & _GEN) ? full : do_enq);
  end // always @(posedge)
  assign io_enq_ready = ~full;
  assign io_deq_valid = _GEN;
  assign io_deq_bits =
    '{hit: (full ? ram_io_deq_bits_MPORT_data.hit : io_enq_bits.hit),
      target: (full ? ram_io_deq_bits_MPORT_data.target : io_enq_bits.target),
      br_type: (full ? ram_io_deq_bits_MPORT_data.br_type : io_enq_bits.br_type),
      GHR: (full ? ram_io_deq_bits_MPORT_data.GHR : io_enq_bits.GHR),
      T_NT: (full ? ram_io_deq_bits_MPORT_data.T_NT : io_enq_bits.T_NT)};
  assign io_count = full;
endmodule

