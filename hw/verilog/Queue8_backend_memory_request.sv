// Generated by CIRCT firtool-1.62.0
module Queue8_backend_memory_request(
  input                                                                                                                                   clock,
                                                                                                                                          reset,
  output                                                                                                                                  io_enq_ready,
  input                                                                                                                                   io_enq_valid,
  input  struct packed {logic [31:0] addr; logic [31:0] data; logic [1:0] memory_type; logic [1:0] access_width; logic [3:0] MOB_index; } io_enq_bits,
  input                                                                                                                                   io_deq_ready,
  output                                                                                                                                  io_deq_valid,
  output struct packed {logic [31:0] addr; logic [31:0] data; logic [1:0] memory_type; logic [1:0] access_width; logic [3:0] MOB_index; } io_deq_bits,
  output [3:0]                                                                                                                            io_count
);

  wire [3:0]  _GEN;
  wire [1:0]  _GEN_0;
  wire [1:0]  _GEN_1;
  wire [31:0] _GEN_2;
  wire [31:0] _GEN_3;
  wire        _GEN_4;
  wire        _GEN_5;
  wire        _GEN_6;
  wire        _GEN_7;
  wire        _GEN_8;
  wire [71:0] _ram_ext_R0_data;
  wire
    struct packed {logic addr; logic data; logic memory_type; logic access_width; logic MOB_index; }
    _GEN_9 = /*cast(bit)*/5'h0;
  wire
    struct packed {logic [31:0] addr; logic [31:0] data; logic [1:0] memory_type; logic [1:0] access_width; logic [3:0] MOB_index; }
    _GEN_10 = /*cast(bit)*/72'h0;
  reg  [2:0]  enq_ptr_value;
  reg  [2:0]  deq_ptr_value;
  reg         maybe_full;
  wire        ptr_match = enq_ptr_value == deq_ptr_value;
  wire        empty = ptr_match & ~maybe_full;
  wire        full = ptr_match & maybe_full;
  wire        do_enq = ~full & io_enq_valid;
  assign _GEN_8 = do_enq | _GEN_9.addr;
  assign _GEN_7 = do_enq | _GEN_9.data;
  assign _GEN_6 = do_enq | _GEN_9.memory_type;
  assign _GEN_5 = do_enq | _GEN_9.access_width;
  assign _GEN_4 = do_enq | _GEN_9.MOB_index;
  assign _GEN_3 = do_enq ? io_enq_bits.addr : _GEN_10.addr;
  assign _GEN_2 = do_enq ? io_enq_bits.data : _GEN_10.data;
  assign _GEN_1 = do_enq ? io_enq_bits.memory_type : _GEN_10.memory_type;
  assign _GEN_0 = do_enq ? io_enq_bits.access_width : _GEN_10.access_width;
  assign _GEN = do_enq ? io_enq_bits.MOB_index : _GEN_10.MOB_index;
  always @(posedge clock) begin
    if (reset) begin
      enq_ptr_value <= 3'h0;
      deq_ptr_value <= 3'h0;
      maybe_full <= 1'h0;
    end
    else begin
      automatic logic do_deq = io_deq_ready & ~empty;
      if (do_enq)
        enq_ptr_value <= enq_ptr_value + 3'h1;
      if (do_deq)
        deq_ptr_value <= deq_ptr_value + 3'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge)
  ram_8x72 ram_ext (
    .R0_addr (deq_ptr_value),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (enq_ptr_value),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({_GEN, _GEN_0, _GEN_1, _GEN_2, _GEN_3}),
    .W0_mask ({{2{_GEN_4}}, _GEN_5, _GEN_6, {16{_GEN_7}}, {16{_GEN_8}}})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits = /*cast(bit)*/_ram_ext_R0_data;
  assign io_count = {maybe_full & ptr_match, enq_ptr_value - deq_ptr_value};
endmodule

