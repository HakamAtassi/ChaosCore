// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for prints and assertions.

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

module AXI_master(
  input                                                                                                                                                                                                                             clock,
                                                                                                                                                                                                                                    reset,
                                                                                                                                                                                                                                    AXI_AW_ready,
  output struct packed {logic [7:0] m_axi_awid; logic [31:0] m_axi_awaddr; logic [7:0] m_axi_awlen; logic [2:0] m_axi_awsize; logic [1:0] m_axi_awburst; logic m_axi_awlock; logic [3:0] m_axi_awcache; logic [2:0] m_axi_awprot; } AXI_AW_bits,
  input                                                                                                                                                                                                                             AXI_W_ready,
  output                                                                                                                                                                                                                            AXI_W_valid,
  output struct packed {logic [31:0] m_axi_wdata; logic [3:0] m_axi_wstrb; logic m_axi_wlast; }                                                                                                                                     AXI_W_bits,
  output                                                                                                                                                                                                                            AXI_B_ready,
  input                                                                                                                                                                                                                             AXI_B_valid,
  input  struct packed {logic [7:0] m_axi_bid; logic [1:0] m_axi_bresp; }                                                                                                                                                           AXI_B_bits,
  input                                                                                                                                                                                                                             AXI_AR_ready,
  output                                                                                                                                                                                                                            AXI_AR_valid,
  output struct packed {logic [7:0] m_axi_arid; logic [31:0] m_axi_araddr; logic [7:0] m_axi_arlen; logic [2:0] m_axi_arsize; logic [1:0] m_axi_arburst; logic m_axi_arlock; logic [3:0] m_axi_arcache; logic [2:0] m_axi_arprot; } AXI_AR_bits,
  output                                                                                                                                                                                                                            AXI_R_ready,
  input                                                                                                                                                                                                                             AXI_R_valid,
  input  struct packed {logic [7:0] m_axi_rid; logic [31:0] m_axi_rdata; logic [1:0] m_axi_rresp; logic m_axi_rlast; }                                                                                                              AXI_R_bits
);

  wire         _final_response_buffer_io_deq_valid;
  wire [255:0] _final_response_buffer_io_deq_bits;
  reg  [255:0] AXI_AW_DATA_BUFFER;
  reg  [2:0]   AXI_REQUEST_STATE;
  wire         _GEN = AXI_REQUEST_STATE == 3'h0;
  wire         _GEN_0 = AXI_REQUEST_STATE == 3'h2;
  wire         _GEN_1 = AXI_REQUEST_STATE == 3'h4;
  wire         _GEN_2 = AXI_REQUEST_STATE == 3'h3;
  reg  [255:0] AXI_read_buffer;
  wire         _GEN_3 = _GEN_2 & AXI_R_valid;
  wire         _GEN_4 = _GEN_3 & AXI_R_bits.m_axi_rlast;
  wire [255:0] _GEN_5 = {AXI_read_buffer[223:0], AXI_R_bits.m_axi_rdata};
  reg  [31:0]  AXI_MASTER_WRITE_ADDRESS;
  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if ((`PRINTF_COND_) & AXI_AW_ready & ~reset)
        $fwrite(32'h80000002, "AXI write accepted");
      if ((`PRINTF_COND_) & ~AXI_AW_ready & ~reset)
        $fwrite(32'h80000002, "AXI write not accepted");
      if ((`PRINTF_COND_) & 1'h0) begin
        $fwrite(32'h80000002, "AXI read accepted");
        $fwrite(32'h80000002, "AXI read not accepted");
      end
      if ((`PRINTF_COND_) & _final_response_buffer_io_deq_valid & ~reset)
        $fwrite(32'h80000002, "%d\n", _final_response_buffer_io_deq_bits);
    end // always @(posedge)
  `endif // not def SYNTHESIS
  always @(posedge clock) begin
    if (AXI_AW_ready)
      AXI_AW_DATA_BUFFER <= {224'h0, AXI_MASTER_WRITE_ADDRESS};
    else if (_GEN_0 & AXI_W_ready)
      AXI_AW_DATA_BUFFER <= {32'h0, AXI_AW_DATA_BUFFER[255:32]};
    if (~_GEN_2 | _GEN_4 | ~_GEN_3) begin
    end
    else
      AXI_read_buffer <= _GEN_5;
    if (reset) begin
      AXI_REQUEST_STATE <= 3'h0;
      AXI_MASTER_WRITE_ADDRESS <= 32'h0;
    end
    else begin
      if (_GEN) begin
        if (AXI_AW_ready)
          AXI_REQUEST_STATE <= 3'h2;
        else
          AXI_REQUEST_STATE <= {2'h0, AXI_AR_ready & _GEN};
      end
      else if (_GEN_0)
        AXI_REQUEST_STATE <= {_GEN_0, 2'h0};
      else if (_GEN_1 | ~(_GEN_2 & AXI_R_bits.m_axi_rlast))
        AXI_REQUEST_STATE <= 3'h0;
      else
        AXI_REQUEST_STATE <= 3'h3;
      AXI_MASTER_WRITE_ADDRESS <= AXI_MASTER_WRITE_ADDRESS + 32'h1;
    end
  end // always @(posedge)
  Queue1_UInt256 final_response_buffer (
    .clock        (clock),
    .reset        (reset),
    .io_enq_ready (/* unused */),
    .io_enq_valid (_GEN_2 & _GEN_4),
    .io_enq_bits  (_GEN_5),
    .io_deq_valid (_final_response_buffer_io_deq_valid),
    .io_deq_bits  (_final_response_buffer_io_deq_bits),
    .io_count     (/* unused */)
  );
  assign AXI_AW_bits =
    '{m_axi_awid: (8'h0),
      m_axi_awaddr: AXI_MASTER_WRITE_ADDRESS,
      m_axi_awlen: (8'h0),
      m_axi_awsize: (3'h0),
      m_axi_awburst: (2'h0),
      m_axi_awlock: (1'h0),
      m_axi_awcache: (4'h0),
      m_axi_awprot: (3'h0)};
  assign AXI_W_valid = _GEN_0;
  assign AXI_W_bits =
    '{m_axi_wdata: (_GEN_0 ? AXI_AW_DATA_BUFFER[31:0] : 32'h0),
      m_axi_wstrb: {3'h0, _GEN_0},
      m_axi_wlast: _GEN_0};
  assign AXI_B_ready = _GEN_1;
  assign AXI_AR_valid = _GEN;
  assign AXI_AR_bits =
    '{m_axi_arid: 8'h0,
      m_axi_araddr: 32'h0,
      m_axi_arlen: 8'h0,
      m_axi_arsize: 3'h0,
      m_axi_arburst: 2'h0,
      m_axi_arlock: 1'h0,
      m_axi_arcache: 4'h0,
      m_axi_arprot: 3'h0};
  assign AXI_R_ready = _GEN_2;
endmodule

