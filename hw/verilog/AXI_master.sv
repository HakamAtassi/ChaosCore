// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for prints and assertions.

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

module AXI_master(
  input                                                                                                                                                                                                                             clock,
                                                                                                                                                                                                                                    reset,
                                                                                                                                                                                                                                    AXI_AW_ready,
  output                                                                                                                                                                                                                            AXI_AW_valid,
  output struct packed {logic [7:0] m_axi_awid; logic [31:0] m_axi_awaddr; logic [7:0] m_axi_awlen; logic [2:0] m_axi_awsize; logic [1:0] m_axi_awburst; logic m_axi_awlock; logic [3:0] m_axi_awcache; logic [2:0] m_axi_awprot; } AXI_AW_bits,
  input                                                                                                                                                                                                                             AXI_W_ready,
  output                                                                                                                                                                                                                            AXI_W_valid,
  output struct packed {logic [31:0] m_axi_wdata; logic [3:0] m_axi_wstrb; logic m_axi_wlast; }                                                                                                                                     AXI_W_bits,
  output                                                                                                                                                                                                                            AXI_B_ready,
  input                                                                                                                                                                                                                             AXI_B_valid,
  input  struct packed {logic [7:0] m_axi_bid; logic [1:0] m_axi_bresp; }                                                                                                                                                           AXI_B_bits,
  input                                                                                                                                                                                                                             AXI_AR_ready,
  output                                                                                                                                                                                                                            AXI_AR_valid,
  output struct packed {logic [7:0] m_axi_arid; logic [31:0] m_axi_araddr; logic [7:0] m_axi_arlen; logic [2:0] m_axi_arsize; logic [1:0] m_axi_arburst; logic m_axi_arlock; logic [3:0] m_axi_arcache; logic [2:0] m_axi_arprot; } AXI_AR_bits,
  output                                                                                                                                                                                                                            AXI_R_ready,
  input                                                                                                                                                                                                                             AXI_R_valid,
  input  struct packed {logic [7:0] m_axi_rid; logic [31:0] m_axi_rdata; logic [1:0] m_axi_rresp; logic m_axi_rlast; }                                                                                                              AXI_R_bits
);

  wire [1:0]   _GEN;
  wire [2:0]   _GEN_0;
  wire [7:0]   _GEN_1;
  wire [1:0]   _GEN_2;
  wire [2:0]   _GEN_3;
  wire [7:0]   _GEN_4;
  wire         _final_response_buffer_io_deq_valid;
  wire [255:0] _final_response_buffer_io_deq_bits;
  reg  [255:0] AXI_AW_DATA_BUFFER;
  reg  [1:0]   AXI_REQUEST_STATE;
  wire         _GEN_5 = AXI_REQUEST_STATE == 2'h1;
  wire         _GEN_6 = AXI_REQUEST_STATE == 2'h2;
  wire         _GEN_7 = _GEN_6 & AXI_R_valid;
  reg  [31:0]  write_counter;
  wire         _GEN_8 = _GEN_5 & write_counter == 32'h0;
  reg  [255:0] AXI_read_buffer;
  wire         _GEN_9 = _GEN_7 & AXI_R_bits.m_axi_rlast;
  wire [255:0] _GEN_10 = {AXI_read_buffer[223:0], AXI_R_bits.m_axi_rdata};
  reg  [1:0]   AXI_MASTER_STATE;
  wire         _GEN_11 = AXI_MASTER_STATE == 2'h0;
  wire         _GEN_12 = _GEN_11 & ~(|AXI_REQUEST_STATE);
  assign _GEN_4 = _GEN_11 ? 8'h7 : 8'h0;
  assign _GEN_3 = _GEN_11 ? 3'h5 : 3'h0;
  assign _GEN_2 = {1'h0, _GEN_11};
  wire         _GEN_13 = AXI_MASTER_STATE == 2'h1;
  wire         _GEN_14 = ~_GEN_11 & _GEN_13 & ~(|AXI_REQUEST_STATE);
  wire         _GEN_15 = _GEN_11 | ~_GEN_13;
  assign _GEN_1 = _GEN_15 ? 8'h0 : 8'h7;
  assign _GEN_0 = _GEN_15 ? 3'h0 : 3'h5;
  assign _GEN = _GEN_11 ? 2'h0 : {1'h0, _GEN_13};
  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if ((`PRINTF_COND_) & _final_response_buffer_io_deq_valid & ~reset)
        $fwrite(32'h80000002, "Read Resp: %x\n", _final_response_buffer_io_deq_bits);
    end // always @(posedge)
  `endif // not def SYNTHESIS
  always @(posedge clock) begin
    automatic logic _GEN_16;
    automatic logic _GEN_17;
    automatic logic _GEN_18;
    _GEN_16 = AXI_AW_ready & _GEN_12;
    _GEN_17 = AXI_W_ready & _GEN_5;
    _GEN_18 = _GEN_5 & _GEN_17;
    if (_GEN_11 & _GEN_16)
      AXI_AW_DATA_BUFFER <=
        256'h102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F;
    else if (_GEN_18)
      AXI_AW_DATA_BUFFER <= {32'h0, AXI_AW_DATA_BUFFER[255:32]};
    if (~_GEN_6 | _GEN_9 | ~_GEN_7) begin
    end
    else
      AXI_read_buffer <= _GEN_10;
    if (reset) begin
      AXI_REQUEST_STATE <= 2'h0;
      write_counter <= 32'h0;
      AXI_MASTER_STATE <= 2'h0;
    end
    else begin
      automatic logic _GEN_19;
      _GEN_19 = AXI_AR_ready & _GEN_14;
      if (|AXI_REQUEST_STATE) begin
        if (_GEN_5) begin
          if (_GEN_8 & _GEN_17)
            AXI_REQUEST_STATE <= 2'h3;
        end
        else if ((&AXI_REQUEST_STATE)
                   ? (&AXI_REQUEST_STATE) & AXI_B_valid
                   : _GEN_6 & AXI_R_bits.m_axi_rlast & _GEN_7)
          AXI_REQUEST_STATE <= 2'h0;
      end
      else if (_GEN_16)
        AXI_REQUEST_STATE <= 2'h1;
      else
        AXI_REQUEST_STATE <= {_GEN_19, 1'h0};
      if (_GEN_18)
        write_counter <= write_counter - 32'h1;
      else if (~(|AXI_REQUEST_STATE) & _GEN_16)
        write_counter <= {24'h0, _GEN_4};
      if (_GEN_11) begin
        if (_GEN_16)
          AXI_MASTER_STATE <= 2'h1;
      end
      else if (_GEN_13 & _GEN_19)
        AXI_MASTER_STATE <= 2'h2;
    end
  end // always @(posedge)
  Queue1_UInt256 final_response_buffer (
    .clock        (clock),
    .reset        (reset),
    .io_enq_ready (/* unused */),
    .io_enq_valid (_GEN_6 & _GEN_9),
    .io_enq_bits  (_GEN_10),
    .io_deq_valid (_final_response_buffer_io_deq_valid),
    .io_deq_bits  (_final_response_buffer_io_deq_bits),
    .io_count     (/* unused */)
  );
  assign AXI_AW_valid = _GEN_12;
  assign AXI_AW_bits =
    '{m_axi_awid: (8'h0),
      m_axi_awaddr: (32'h0),
      m_axi_awlen: _GEN_4,
      m_axi_awsize: _GEN_3,
      m_axi_awburst: _GEN_2,
      m_axi_awlock: (1'h0),
      m_axi_awcache: (4'h0),
      m_axi_awprot: (3'h0)};
  assign AXI_W_valid = _GEN_5;
  assign AXI_W_bits =
    '{m_axi_wdata: (_GEN_5 ? AXI_AW_DATA_BUFFER[31:0] : 32'h0),
      m_axi_wstrb: {4{_GEN_5}},
      m_axi_wlast: _GEN_8};
  assign AXI_B_ready = &AXI_REQUEST_STATE;
  assign AXI_AR_valid = _GEN_14;
  assign AXI_AR_bits =
    '{m_axi_arid: (8'h0),
      m_axi_araddr: (32'h0),
      m_axi_arlen: _GEN_1,
      m_axi_arsize: _GEN_0,
      m_axi_arburst: _GEN,
      m_axi_arlock: (1'h0),
      m_axi_arcache: (4'h0),
      m_axi_arprot: (3'h0)};
  assign AXI_R_ready = _GEN_6;
endmodule

