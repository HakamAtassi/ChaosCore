// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for prints and assertions.

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

module CSRs(
  input         clock,
                reset,
                io_flush_valid,
                io_FU_input_valid,
  input  [6:0]  io_FU_input_bits_decoded_instruction_PRD,
  input         io_FU_input_bits_decoded_instruction_RD_valid,
  input  [20:0] io_FU_input_bits_decoded_instruction_IMM,
  input  [1:0]  io_FU_input_bits_decoded_instruction_packet_index,
  input  [5:0]  io_FU_input_bits_decoded_instruction_ROB_index,
  input  [3:0]  io_FU_input_bits_decoded_instruction_MOB_index,
  input  [4:0]  io_FU_input_bits_decoded_instruction_instructionType,
  input         io_FU_input_bits_decoded_instruction_needs_ALU,
                io_FU_input_bits_decoded_instruction_needs_branch_unit,
                io_FU_input_bits_decoded_instruction_needs_CSRs,
                io_FU_input_bits_decoded_instruction_MULTIPLY,
  input  [31:0] io_FU_input_bits_fetch_PC,
  output        io_FU_output_valid,
  output [6:0]  io_FU_output_bits_PRD,
  output [31:0] io_FU_output_bits_RD_data,
  output        io_FU_output_bits_RD_valid,
  output [31:0] io_FU_output_bits_fetch_PC,
  output [3:0]  io_FU_output_bits_MOB_index,
  output [5:0]  io_FU_output_bits_ROB_index,
  output [1:0]  io_FU_output_bits_fetch_packet_index,
  input         io_partial_commit_valid_0,
                io_partial_commit_valid_1,
                io_partial_commit_valid_2,
                io_partial_commit_valid_3
);

  wire        CSR_input_valid;
  wire [31:0] instruction_PC =
    io_FU_input_bits_fetch_PC
    + {28'h0, io_FU_input_bits_decoded_instruction_packet_index, 2'h0};
  wire        AUIPC =
    io_FU_input_bits_decoded_instruction_instructionType == 5'h5
    & ~io_FU_input_bits_decoded_instruction_MULTIPLY;
  wire        ALU_input_valid =
    io_FU_input_valid & io_FU_input_bits_decoded_instruction_needs_ALU;
  wire        branch_unit_input_valid =
    io_FU_input_valid & io_FU_input_bits_decoded_instruction_needs_branch_unit;
  wire        mult_unit_input_valid =
    io_FU_input_valid & io_FU_input_bits_decoded_instruction_MULTIPLY;
  assign CSR_input_valid =
    io_FU_input_valid & io_FU_input_bits_decoded_instruction_needs_CSRs;
  wire        input_valid = CSR_input_valid;
  reg         io_FU_output_valid_REG;
  reg  [63:0] cycle_reg;
  reg  [63:0] time_reg;
  reg  [63:0] instret_reg;
  reg  [31:0] CSR_out;
  reg  [31:0] io_FU_output_bits_fetch_PC_REG;
  reg  [1:0]  io_FU_output_bits_fetch_packet_index_REG;
  reg  [6:0]  io_FU_output_bits_PRD_REG;
  reg         io_FU_output_bits_RD_valid_REG;
  reg  [3:0]  io_FU_output_bits_MOB_index_REG;
  reg  [5:0]  io_FU_output_bits_ROB_index_REG;
  always @(posedge clock) begin
    io_FU_output_valid_REG <= input_valid & ~io_flush_valid;
    if (io_FU_input_bits_decoded_instruction_IMM[11:0] == 12'hC00)
      CSR_out <= cycle_reg[31:0];
    else if (io_FU_input_bits_decoded_instruction_IMM[11:0] == 12'hC01)
      CSR_out <= time_reg[31:0];
    else if (io_FU_input_bits_decoded_instruction_IMM[11:0] == 12'hC02)
      CSR_out <= instret_reg[31:0];
    else if (io_FU_input_bits_decoded_instruction_IMM[11:0] == 12'hC80)
      CSR_out <= time_reg[31:0];
    else if (io_FU_input_bits_decoded_instruction_IMM[11:0] == 12'hC81)
      CSR_out <= cycle_reg[63:32];
    else if (io_FU_input_bits_decoded_instruction_IMM[11:0] == 12'hC82)
      CSR_out <= instret_reg[63:32];
    io_FU_output_bits_fetch_PC_REG <= io_FU_input_bits_fetch_PC;
    io_FU_output_bits_fetch_packet_index_REG <=
      io_FU_input_bits_decoded_instruction_packet_index;
    io_FU_output_bits_PRD_REG <= io_FU_input_bits_decoded_instruction_PRD;
    io_FU_output_bits_RD_valid_REG <= io_FU_input_bits_decoded_instruction_RD_valid;
    io_FU_output_bits_MOB_index_REG <= io_FU_input_bits_decoded_instruction_MOB_index;
    io_FU_output_bits_ROB_index_REG <= io_FU_input_bits_decoded_instruction_ROB_index;
    if (reset) begin
      cycle_reg <= 64'h0;
      time_reg <= 64'h0;
      instret_reg <= 64'h0;
    end
    else begin
      cycle_reg <= cycle_reg + 64'h1;
      time_reg <= time_reg + 64'h1;
      instret_reg <=
        instret_reg
        + {61'h0,
           {1'h0, {1'h0, io_partial_commit_valid_0} + {1'h0, io_partial_commit_valid_1}}
             + {1'h0,
                {1'h0, io_partial_commit_valid_2} + {1'h0, io_partial_commit_valid_3}}};
    end
  end // always @(posedge)
  assign io_FU_output_valid = io_FU_output_valid_REG & ~io_flush_valid;
  assign io_FU_output_bits_PRD = io_FU_output_bits_PRD_REG;
  assign io_FU_output_bits_RD_data = CSR_out;
  assign io_FU_output_bits_RD_valid = io_FU_output_bits_RD_valid_REG;
  assign io_FU_output_bits_fetch_PC = io_FU_output_bits_fetch_PC_REG;
  assign io_FU_output_bits_MOB_index = io_FU_output_bits_MOB_index_REG;
  assign io_FU_output_bits_ROB_index = io_FU_output_bits_ROB_index_REG;
  assign io_FU_output_bits_fetch_packet_index = io_FU_output_bits_fetch_packet_index_REG;
endmodule

