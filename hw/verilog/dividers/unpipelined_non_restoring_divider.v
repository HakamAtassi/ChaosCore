// Generated by CIRCT firtool-1.62.0
module unpipelined_non_restoring_divider(
  input         clock,
                reset,
  output        io_dividend_ready,
  input         io_dividend_valid,
  input  [31:0] io_dividend_bits,
  output        io_divisor_ready,
  input         io_divisor_valid,
  input  [31:0] io_divisor_bits,
  output        io_signed_ready,
  input         io_signed_valid,
                io_signed_bits,
                io_quotient_ready,
  output        io_quotient_valid,
  output [31:0] io_quotient_bits,
  input         io_remainder_ready,
  output        io_remainder_valid,
  output [31:0] io_remainder_bits
);

  reg  [31:0] quotient;
  reg  [32:0] partial_remainder;
  reg  [31:0] dividend;
  reg  [31:0] divisor;
  reg         dividend_sign_bit;
  reg         divisor_sign_bit;
  reg  [4:0]  state_counter;
  reg  [1:0]  division_state;
  wire        _GEN = division_state == 2'h0;
  wire        _GEN_0 = division_state == 2'h1;
  wire        _GEN_1 = _GEN | _GEN_0 | division_state == 2'h2;
  wire        io_divisor_ready_0 = ~_GEN_1 & (&division_state);
  wire        _GEN_2 = _GEN_1 | ~(&division_state);
  wire [32:0] _GEN_3 = {partial_remainder[31:0], dividend[31]};
  wire [32:0] _GEN_4 = {1'h0, divisor};
  wire [32:0] _partial_remainder_next_T = _GEN_3 + _GEN_4;
  wire [32:0] _partial_remainder_next_T_2 = _GEN_3 - _GEN_4;
  always @(posedge clock) begin
    if (reset) begin
      quotient <= 32'h0;
      partial_remainder <= 33'h0;
      dividend <= 32'h0;
      divisor <= 32'h0;
      dividend_sign_bit <= 1'h0;
      divisor_sign_bit <= 1'h0;
      state_counter <= 5'h0;
      division_state <= 2'h0;
    end
    else begin
      automatic logic [3:0][1:0] _GEN_5 =
        {{2'h0},
         {2'h3},
         {(&state_counter) ? 2'h3 : division_state},
         {io_dividend_valid & io_divisor_valid & io_signed_valid
            ? 2'h1
            : division_state}};
      if (_GEN) begin
        quotient <= 32'h0;
        partial_remainder <= 33'h0;
        dividend <=
          io_dividend_bits[31] & io_signed_bits
            ? ~io_dividend_bits + 32'h1
            : io_dividend_bits;
        divisor <=
          io_divisor_bits[31] & io_signed_bits
            ? ~io_divisor_bits + 32'h1
            : io_divisor_bits;
      end
      else if (_GEN_0) begin
        quotient <=
          {quotient[30:0],
           ~(partial_remainder[32]
               ? _partial_remainder_next_T[32]
               : _partial_remainder_next_T_2[32])};
        if (partial_remainder[32])
          partial_remainder <= _partial_remainder_next_T;
        else
          partial_remainder <= _partial_remainder_next_T_2;
        dividend <= {dividend[30:0], 1'h0};
      end
      if (_GEN & io_signed_bits) begin
        dividend_sign_bit <= io_dividend_bits[31];
        divisor_sign_bit <= io_divisor_bits[31];
      end
      if (_GEN | ~_GEN_0) begin
      end
      else
        state_counter <= state_counter + 5'h1;
      division_state <= _GEN_5[division_state];
    end
  end // always @(posedge)
  assign io_dividend_ready = io_divisor_ready_0;
  assign io_divisor_ready = io_divisor_ready_0;
  assign io_signed_ready = 1'h0;
  assign io_quotient_valid = io_divisor_ready_0;
  assign io_quotient_bits =
    _GEN_2 ? 32'h0 : dividend_sign_bit ^ divisor_sign_bit ? ~quotient + 32'h1 : quotient;
  assign io_remainder_valid = io_divisor_ready_0;
  assign io_remainder_bits = _GEN_2 ? 32'h0 : partial_remainder[31:0];
endmodule

