// Generated by CIRCT firtool-1.62.0
module ALU(
  input         clock,
                reset,
  output        io_FU_input_ready,
  input         io_FU_input_valid,
  input  [5:0]  io_FU_input_bits_RD,
                io_FU_input_bits_RS1,
                io_FU_input_bits_RS2,
  input  [31:0] io_FU_input_bits_IMM,
  input  [2:0]  io_FU_input_bits_FUNCT3,
  input  [3:0]  io_FU_input_bits_packet_index,
  input  [4:0]  io_FU_input_bits_instructionType,
  input         io_FU_input_bits_SUBTRACT,
                io_FU_input_bits_MULTIPLY,
                io_FU_input_bits_IMMEDIATE,
  input  [31:0] io_FU_input_bits_RS1_data,
                io_FU_input_bits_RS2_data,
                io_FU_input_bits_PC,
  output        io_FU_output_RD_valid,
  output [63:0] io_FU_output_RD_bits,
  output [31:0] io_FU_output_data,
  output        io_FU_output_branch_taken,
  output [31:0] io_FU_output_branch_address
);

  reg [31:0] arithmetic_result;
  reg [31:0] add_result;
  reg [31:0] sub_result;
  reg [31:0] slt_result;
  reg [31:0] sltu_result;
  reg [31:0] and_result;
  reg [31:0] or_result;
  reg [31:0] xor_result;
  reg [31:0] sll_result;
  reg [31:0] srl_result;
  reg [31:0] sra_result;
  always @(posedge clock) begin
    if (reset) begin
      arithmetic_result <= 32'h0;
      add_result <= 32'h0;
      sub_result <= 32'h0;
      slt_result <= 32'h0;
      sltu_result <= 32'h0;
      and_result <= 32'h0;
      or_result <= 32'h0;
      xor_result <= 32'h0;
      sll_result <= 32'h0;
      srl_result <= 32'h0;
      sra_result <= 32'h0;
    end
    else begin
      automatic logic [31:0] operand2 =
        io_FU_input_bits_IMMEDIATE ? io_FU_input_bits_IMM : io_FU_input_bits_RS2_data;
      automatic logic [31:0] _GEN = {27'h0, operand2[4:0]};
      automatic logic        _REMU_T;
      automatic logic        _MUL_T_1;
      automatic logic [62:0] _sll_result_T_1 =
        {31'h0, io_FU_input_bits_RS1_data} << operand2[4:0];
      _REMU_T = io_FU_input_bits_instructionType == 5'hC;
      _MUL_T_1 = io_FU_input_bits_FUNCT3 == 3'h0;
      if (_REMU_T & _MUL_T_1 & ~io_FU_input_bits_MULTIPLY & io_FU_input_bits_SUBTRACT)
        arithmetic_result <= add_result;
      else if (_REMU_T & _MUL_T_1 & ~io_FU_input_bits_MULTIPLY
               & io_FU_input_bits_SUBTRACT)
        arithmetic_result <= sub_result;
      else if (_REMU_T & io_FU_input_bits_FUNCT3 == 3'h4 & ~io_FU_input_bits_MULTIPLY)
        arithmetic_result <= xor_result;
      else if (_REMU_T & io_FU_input_bits_FUNCT3 == 3'h6 & ~io_FU_input_bits_MULTIPLY)
        arithmetic_result <= or_result;
      else if (_REMU_T & (&io_FU_input_bits_FUNCT3) & ~io_FU_input_bits_MULTIPLY)
        arithmetic_result <= and_result;
      else if (_REMU_T & io_FU_input_bits_FUNCT3 == 3'h1 & ~io_FU_input_bits_MULTIPLY)
        arithmetic_result <= sll_result;
      else begin
        automatic logic _DIVU_T_1;
        _DIVU_T_1 = io_FU_input_bits_FUNCT3 == 3'h5;
        if (_REMU_T & _DIVU_T_1 & ~io_FU_input_bits_MULTIPLY)
          arithmetic_result <= srl_result;
        else if (_REMU_T & _DIVU_T_1 & ~io_FU_input_bits_MULTIPLY)
          arithmetic_result <= sra_result;
        else if (_REMU_T & io_FU_input_bits_FUNCT3 == 3'h2 & ~io_FU_input_bits_MULTIPLY)
          arithmetic_result <= slt_result;
        else if (_REMU_T & io_FU_input_bits_FUNCT3 == 3'h3 & ~io_FU_input_bits_MULTIPLY)
          arithmetic_result <= sltu_result;
      end
      add_result <= io_FU_input_bits_RS1_data + operand2;
      sub_result <= io_FU_input_bits_RS1_data - operand2;
      slt_result <= {31'h0, $signed(io_FU_input_bits_RS1_data) < $signed(operand2)};
      sltu_result <= {31'h0, io_FU_input_bits_RS1_data < operand2};
      and_result <= io_FU_input_bits_RS1_data & operand2;
      or_result <= io_FU_input_bits_RS1_data | operand2;
      xor_result <= io_FU_input_bits_RS1_data ^ operand2;
      sll_result <= _sll_result_T_1[31:0];
      srl_result <= io_FU_input_bits_RS1_data >> _GEN;
      sra_result <= $signed($signed(io_FU_input_bits_RS1_data) >>> _GEN);
    end
  end // always @(posedge)
  assign io_FU_input_ready = 1'h0;
  assign io_FU_output_RD_valid = 1'h0;
  assign io_FU_output_RD_bits = {58'h0, io_FU_input_bits_RD};
  assign io_FU_output_data = arithmetic_result;
  assign io_FU_output_branch_taken = 1'h0;
  assign io_FU_output_branch_address = 32'h0;
endmodule

