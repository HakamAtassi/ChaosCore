// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for prints and assertions.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

module FU(
  input                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            clock,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   reset,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   io_flush,
  output                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           io_FU_input_ready,
  input                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            io_FU_input_valid,
  input  struct packed {struct packed {struct packed {logic RS1_ready; logic RS2_ready; } ready_bits; logic [4:0] RDold; logic [6:0] RD; logic RD_valid; logic [6:0] RS1; logic RS1_valid; logic [6:0] RS2; logic RS2_valid; logic [20:0] IMM; logic [2:0] FUNCT3; logic [1:0] packet_index; logic [5:0] ROB_index; logic [3:0] MOB_index; logic [3:0] FTQ_index; logic [4:0] instructionType; logic [1:0] portID; logic [1:0] RS_type; logic needs_ALU; logic needs_branch_unit; logic needs_CSRs; logic SUBTRACT; logic MULTIPLY; logic IS_IMM; logic [1:0] memory_type; logic [1:0] access_width; } decoded_instruction; logic [31:0] RS1_data; logic [31:0] RS2_data; logic [31:0] fetch_PC; } io_FU_input_bits,
  output struct packed {logic valid; struct packed {logic [6:0] RD; logic [31:0] RD_data; logic RD_valid; logic [31:0] fetch_PC; logic branch_taken; logic [31:0] target_address; logic branch_valid; logic [31:0] address; logic [1:0] memory_type; logic [1:0] access_width; logic is_unsigned; logic [31:0] wr_data; logic [3:0] MOB_index; logic [5:0] ROB_index; logic [3:0] FTQ_index; logic [1:0] fetch_packet_index; logic exception; } bits; }                                                                                                                                                                                                                                            io_FU_output
);

  wire
    struct packed {logic valid; struct packed {logic [6:0] RD; logic [31:0] RD_data; logic RD_valid; logic [31:0] fetch_PC; logic branch_taken; logic [31:0] target_address; logic branch_valid; logic [31:0] address; logic [1:0] memory_type; logic [1:0] access_width; logic is_unsigned; logic [31:0] wr_data; logic [3:0] MOB_index; logic [5:0] ROB_index; logic [3:0] FTQ_index; logic [1:0] fetch_packet_index; logic exception; } bits; }
    _branch_unit_io_FU_output;
  wire
    struct packed {logic valid; struct packed {logic [6:0] RD; logic [31:0] RD_data; logic RD_valid; logic [31:0] fetch_PC; logic branch_taken; logic [31:0] target_address; logic branch_valid; logic [31:0] address; logic [1:0] memory_type; logic [1:0] access_width; logic is_unsigned; logic [31:0] wr_data; logic [3:0] MOB_index; logic [5:0] ROB_index; logic [3:0] FTQ_index; logic [1:0] fetch_packet_index; logic exception; } bits; }
    _ALU_io_FU_output;
  reg  REG_1;
  reg  monitor_output_REG;
  wire monitor_output = monitor_output_REG;
  wire
    struct packed {logic [6:0] RD; logic [31:0] RD_data; logic RD_valid; logic [31:0] fetch_PC; logic branch_taken; logic [31:0] target_address; logic branch_valid; logic [31:0] address; logic [1:0] memory_type; logic [1:0] access_width; logic is_unsigned; logic [31:0] wr_data; logic [3:0] MOB_index; logic [5:0] ROB_index; logic [3:0] FTQ_index; logic [1:0] fetch_packet_index; logic exception; }
    _GEN =
    '{RD: (REG_1 ? _branch_unit_io_FU_output.bits.RD : _ALU_io_FU_output.bits.RD),
      RD_data:
        (REG_1 ? _branch_unit_io_FU_output.bits.RD_data : _ALU_io_FU_output.bits.RD_data),
      RD_valid:
        (REG_1
           ? _branch_unit_io_FU_output.bits.RD_valid
           : _ALU_io_FU_output.bits.RD_valid),
      fetch_PC:
        (REG_1
           ? _branch_unit_io_FU_output.bits.fetch_PC
           : _ALU_io_FU_output.bits.fetch_PC),
      branch_taken:
        (REG_1
           ? _branch_unit_io_FU_output.bits.branch_taken
           : _ALU_io_FU_output.bits.branch_taken),
      target_address:
        (REG_1
           ? _branch_unit_io_FU_output.bits.target_address
           : _ALU_io_FU_output.bits.target_address),
      branch_valid:
        (REG_1
           ? _branch_unit_io_FU_output.bits.branch_valid
           : _ALU_io_FU_output.bits.branch_valid),
      address:
        (REG_1 ? _branch_unit_io_FU_output.bits.address : _ALU_io_FU_output.bits.address),
      memory_type:
        (REG_1
           ? _branch_unit_io_FU_output.bits.memory_type
           : _ALU_io_FU_output.bits.memory_type),
      access_width:
        (REG_1
           ? _branch_unit_io_FU_output.bits.access_width
           : _ALU_io_FU_output.bits.access_width),
      is_unsigned:
        (REG_1
           ? _branch_unit_io_FU_output.bits.is_unsigned
           : _ALU_io_FU_output.bits.is_unsigned),
      wr_data:
        (REG_1 ? _branch_unit_io_FU_output.bits.wr_data : _ALU_io_FU_output.bits.wr_data),
      MOB_index:
        (REG_1
           ? _branch_unit_io_FU_output.bits.MOB_index
           : _ALU_io_FU_output.bits.MOB_index),
      ROB_index:
        (REG_1
           ? _branch_unit_io_FU_output.bits.ROB_index
           : _ALU_io_FU_output.bits.ROB_index),
      FTQ_index:
        (REG_1
           ? _branch_unit_io_FU_output.bits.FTQ_index
           : _ALU_io_FU_output.bits.FTQ_index),
      fetch_packet_index:
        (REG_1
           ? _branch_unit_io_FU_output.bits.fetch_packet_index
           : _ALU_io_FU_output.bits.fetch_packet_index),
      exception:
        (REG_1
           ? _branch_unit_io_FU_output.bits.exception
           : _ALU_io_FU_output.bits.exception)};
  always @(posedge clock) begin
    REG_1 <= io_FU_input_bits.decoded_instruction.needs_branch_unit & io_FU_input_valid;
    monitor_output_REG <= io_FU_input_valid;
  end // always @(posedge)
  ALU ALU (
    .clock             (clock),
    .reset             (reset),
    .io_flush          (io_flush),
    .io_FU_input_valid (io_FU_input_valid),
    .io_FU_input_bits  (io_FU_input_bits),
    .io_FU_output      (_ALU_io_FU_output)
  );
  branch_unit branch_unit (
    .clock             (clock),
    .io_flush          (io_flush),
    .io_FU_input_valid (io_FU_input_valid),
    .io_FU_input_bits  (io_FU_input_bits),
    .io_FU_output      (_branch_unit_io_FU_output)
  );
  assign io_FU_input_ready = 1'h1;
  assign io_FU_output =
    '{valid: (REG_1 ? _branch_unit_io_FU_output.valid : _ALU_io_FU_output.valid),
      bits: _GEN};
endmodule

