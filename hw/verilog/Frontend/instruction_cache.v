// Generated by CIRCT firtool-1.62.0
// VCS coverage exclude_file
module mem_64x2(
  input  [5:0] R0_addr,
  input        R0_en,
               R0_clk,
  output [1:0] R0_data,
  input  [5:0] W0_addr,
  input        W0_en,
               W0_clk,
  input  [1:0] W0_data
);

  reg [1:0] Memory[0:63];
  reg       _R0_en_d0;
  reg [5:0] _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 2'bx;
endmodule

module SDPReadWriteSmem(
  input        clock,
               reset,
  input  [5:0] io_rd_addr,
  output [1:0] io_data_out,
  input  [5:0] io_wr_addr,
  input        io_wr_en,
  input  [1:0] io_data_in
);

  wire [1:0] _mem_ext_R0_data;
  reg        hazard_reg;
  reg  [1:0] din_buff;
  always @(posedge clock) begin
    if (reset) begin
      hazard_reg <= 1'h0;
      din_buff <= 2'h0;
    end
    else begin
      hazard_reg <= io_rd_addr == io_wr_addr & io_wr_en;
      din_buff <= io_data_in;
    end
  end // always @(posedge)
  mem_64x2 mem_ext (
    .R0_addr (io_rd_addr),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_mem_ext_R0_data),
    .W0_addr (io_wr_addr),
    .W0_en   (io_wr_en),
    .W0_clk  (clock),
    .W0_data (io_data_in)
  );
  assign io_data_out = hazard_reg ? din_buff : _mem_ext_R0_data;
endmodule

// VCS coverage exclude_file
module ram_64x278(
  input  [5:0]   R0_addr,
  input          R0_en,
                 R0_clk,
  output [277:0] R0_data,
  input  [5:0]   W0_addr,
  input          W0_en,
                 W0_clk,
  input  [277:0] W0_data
);

  reg [277:0] Memory[0:63];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 278'bx;
endmodule

module ReadWriteSmem(
  input          clock,
                 io_wr_en,
  input  [5:0]   io_addr,
  input  [277:0] io_data_in,
  output [277:0] io_data_out
);

  wire [277:0] _ram_ext_R0_data;
  reg  [277:0] dataOut;
  always @(posedge clock)
    dataOut <= _ram_ext_R0_data;
  ram_64x278 ram_ext (
    .R0_addr (io_addr),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (io_addr),
    .W0_en   (io_wr_en),
    .W0_clk  (clock),
    .W0_data (io_data_in)
  );
  assign io_data_out = dataOut;
endmodule

module L1_instruction_cache(
  input          clock,
                 reset,
  output         io_cpu_addr_ready,
  input          io_cpu_addr_valid,
  input  [31:0]  io_cpu_addr_bits,
  output         io_dram_data_ready,
  input          io_dram_data_valid,
  input  [255:0] io_dram_data_bits,
  input          io_cache_data_0_ready,
  output         io_cache_data_0_valid,
  output [31:0]  io_cache_data_0_bits,
  input          io_cache_data_1_ready,
  output         io_cache_data_1_valid,
  output [31:0]  io_cache_data_1_bits,
  input          io_cache_addr_ready,
  output         io_cache_addr_valid,
  output [31:0]  io_cache_addr_bits
);

  wire             miss;
  reg  [1:0]       cache_state;
  reg  [31:0]      replay_addr;
  reg  [20:0]      replay_tag;
  reg              replay_valid;
  wire             _GEN = cache_state == 2'h1;
  wire [31:0]      io_cache_addr_bits_0 = ~(|cache_state) & miss ? replay_addr : 32'h0;
  wire [31:0]      current_addr = (|cache_state) ? replay_addr : io_cpu_addr_bits;
  wire [277:0]     current_data = {1'h1, replay_tag, io_dram_data_bits};
  wire [5:0]       current_set_addr = current_addr[10:5];
  reg  [5:0]       LRU_memory_io_wr_addr_REG;
  reg              LRU_memory_io_wr_en_REG;
  reg  [1:0]       LRU_memory_io_data_in_REG;
  wire [1:0]       LRU;
  wire [1:0]       allocate_way = LRU[1] ? {1'h0, ~(LRU[0])} : 2'h2;
  reg  [31:0]      delayed_current_addr;
  wire [20:0]      delayed_current_address_tag = delayed_current_addr[31:11];
  reg  [20:0]      input_tag;
  wire [277:0]     data_way_0;
  wire             memory_valid_vec_0 = data_way_0[277];
  wire [277:0]     data_way_1;
  wire [20:0]      memory_tags_vec_0 = data_way_0[276:256];
  wire             memory_valid_vec_1 = data_way_1[277];
  wire [20:0]      memory_tags_vec_1 = data_way_1[276:256];
  wire             hit_oh_vec_0 =
    memory_tags_vec_0 == delayed_current_address_tag & memory_valid_vec_0;
  wire             hit_oh_vec_1 =
    memory_tags_vec_1 == delayed_current_address_tag & memory_valid_vec_1;
  wire [1:0]       hit_oh = {hit_oh_vec_1, hit_oh_vec_0};
  reg              hit_REG;
  reg              hit_REG_1;
  wire             hit = (|hit_oh) & (hit_REG | hit_REG_1);
  reg              miss_REG;
  reg              miss_REG_1;
  assign miss = ~(|hit_oh) & (miss_REG | miss_REG_1);
  wire [1:0]       packet_index = delayed_current_addr[4:3];
  wire [255:0]     hit_instruction_data =
    hit_oh_vec_0 | ~hit_oh_vec_1 ? data_way_0[255:0] : data_way_1[255:0];
  wire [7:0][31:0] _GEN_0 =
    {{hit_instruction_data[31:0]},
     {hit_instruction_data[63:32]},
     {hit_instruction_data[95:64]},
     {hit_instruction_data[127:96]},
     {hit_instruction_data[159:128]},
     {hit_instruction_data[191:160]},
     {hit_instruction_data[223:192]},
     {hit_instruction_data[255:224]}};
  always @(posedge clock) begin
    if (reset) begin
      cache_state <= 2'h0;
      replay_addr <= 32'h0;
      replay_tag <= 21'h0;
      replay_valid <= 1'h0;
    end
    else if (|cache_state) begin
      if (_GEN) begin
        if (io_dram_data_valid)
          cache_state <= 2'h2;
        replay_valid <= io_dram_data_valid | replay_valid;
      end
      else begin
        automatic logic _GEN_1 = cache_state == 2'h2;
        if (_GEN_1)
          cache_state <= 2'h0;
        replay_valid <= ~_GEN_1 & replay_valid;
      end
    end
    else begin
      if (miss)
        cache_state <= 2'h1;
      replay_addr <= io_cpu_addr_bits;
      replay_tag <= io_cpu_addr_bits[31:11];
    end
    LRU_memory_io_wr_addr_REG <= current_set_addr;
    LRU_memory_io_wr_en_REG <= hit;
    LRU_memory_io_data_in_REG <= {2{(LRU | hit_oh) != 2'h3}} & LRU | hit_oh;
    delayed_current_addr <= current_addr;
    input_tag <= io_cache_addr_bits_0[31:11];
    hit_REG <= io_cpu_addr_valid;
    hit_REG_1 <= replay_valid;
    miss_REG <= io_cpu_addr_valid;
    miss_REG_1 <= replay_valid;
  end // always @(posedge)
  SDPReadWriteSmem LRU_memory (
    .clock       (clock),
    .reset       (reset),
    .io_rd_addr  (current_set_addr),
    .io_data_out (LRU),
    .io_wr_addr  (LRU_memory_io_wr_addr_REG),
    .io_wr_en    (LRU_memory_io_wr_en_REG),
    .io_data_in  (LRU_memory_io_data_in_REG)
  );
  ReadWriteSmem data_memory_0 (
    .clock       (clock),
    .io_wr_en    (io_dram_data_valid & allocate_way[0]),
    .io_addr     (current_set_addr),
    .io_data_in  (current_data),
    .io_data_out (data_way_0)
  );
  ReadWriteSmem data_memory_1 (
    .clock       (clock),
    .io_wr_en    (io_dram_data_valid & allocate_way[1]),
    .io_addr     (current_set_addr),
    .io_data_in  (current_data),
    .io_data_out (data_way_1)
  );
  assign io_cpu_addr_ready = ~(|cache_state) & ~miss;
  assign io_dram_data_ready = (|cache_state) ? _GEN & ~io_dram_data_valid : miss;
  assign io_cache_data_0_valid = hit & ~(delayed_current_addr[2]);
  assign io_cache_data_0_bits = _GEN_0[{packet_index, 1'h0}];
  assign io_cache_data_1_valid = hit;
  assign io_cache_data_1_bits = _GEN_0[{packet_index, 1'h0} + 3'h1];
  assign io_cache_addr_valid = ~(|cache_state) & miss;
  assign io_cache_addr_bits = io_cache_addr_bits_0;
endmodule

