// Generated by CIRCT firtool-1.62.0
// VCS coverage exclude_file
module ram_64x278(
  input  [5:0]   R0_addr,
  input          R0_en,
                 R0_clk,
  output [277:0] R0_data,
  input  [5:0]   W0_addr,
  input          W0_en,
                 W0_clk,
  input  [277:0] W0_data
);

  reg [277:0] Memory[0:63];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 278'bx;
endmodule

module ReadWriteSmem(
  input          clock,
  input  [5:0]   io_addr,
  output [277:0] io_data_out
);

  wire [277:0] _ram_ext_R0_data;
  reg  [277:0] dataOut;
  always @(posedge clock)
    dataOut <= _ram_ext_R0_data;
  ram_64x278 ram_ext (
    .R0_addr (io_addr),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (io_addr),
    .W0_en   (1'h1),
    .W0_clk  (clock),
    .W0_data (278'h0)
  );
  assign io_data_out = dataOut;
endmodule

module L1_instruction_memory(
  input         clock,
                reset,
  output        io_cpu_addr_ready,
  input         io_cpu_addr_valid,
  input  [31:0] io_cpu_addr_bits,
  output        io_dram_data_ready,
  input         io_dram_data_valid,
  input  [31:0] io_dram_data_bits,
  input         io_cache_data_0_ready,
  output        io_cache_data_0_valid,
  output [31:0] io_cache_data_0_bits,
  input         io_cache_data_1_ready,
  output        io_cache_data_1_valid,
  output [31:0] io_cache_data_1_bits,
  input         io_cache_addr_ready,
  output        io_cache_addr_valid,
  output [31:0] io_cache_addr_bits
);

  wire [277:0] _data_memory_1_io_data_out;
  wire [277:0] _data_memory_0_io_data_out;
  reg  [1:0]   cache_state;
  wire [31:0]  current_addr =
    cache_state == 2'h2 | (&cache_state) ? 32'h0 : io_cpu_addr_bits;
  reg  [31:0]  delayed_current_addr;
  wire         hit_oh_vec_0 =
    {1'h0, _data_memory_0_io_data_out[253:233]} == delayed_current_addr[31:10]
    & _data_memory_0_io_data_out[255];
  wire         hit_oh_vec_1 =
    {1'h0, _data_memory_1_io_data_out[253:233]} == delayed_current_addr[31:10]
    & _data_memory_1_io_data_out[255];
  reg          miss_REG;
  reg  [31:0]  test0;
  reg  [31:0]  test1;
  always @(posedge clock) begin
    if (reset) begin
      cache_state <= 2'h0;
      test0 <= 32'h0;
      test1 <= 32'h0;
    end
    else begin
      automatic logic [255:0]     hit_instruction_data =
        hit_oh_vec_0 | ~hit_oh_vec_1
          ? _data_memory_0_io_data_out[255:0]
          : _data_memory_1_io_data_out[255:0];
      automatic logic [7:0][31:0] _GEN =
        {{hit_instruction_data[255:224]},
         {hit_instruction_data[223:192]},
         {hit_instruction_data[191:160]},
         {hit_instruction_data[159:128]},
         {hit_instruction_data[127:96]},
         {hit_instruction_data[95:64]},
         {hit_instruction_data[63:32]},
         {hit_instruction_data[31:0]}};
      automatic logic [3:0][1:0]  _GEN_0 =
        {{2'h2},
         {2'h0},
         {io_dram_data_valid ? 2'h1 : cache_state},
         {{hit_oh_vec_1, hit_oh_vec_0} == 2'h0 & miss_REG ? 2'h1 : cache_state}};
      cache_state <= _GEN_0[cache_state];
      test0 <= _GEN[{delayed_current_addr[2], 2'h0}];
      test1 <= _GEN[{delayed_current_addr[2], 2'h0} + 3'h1];
    end
    delayed_current_addr <= current_addr;
    miss_REG <= io_cpu_addr_valid;
  end // always @(posedge)
  ReadWriteSmem data_memory_0 (
    .clock       (clock),
    .io_addr     (current_addr[5:0]),
    .io_data_out (_data_memory_0_io_data_out)
  );
  ReadWriteSmem data_memory_1 (
    .clock       (clock),
    .io_addr     (current_addr[5:0]),
    .io_data_out (_data_memory_1_io_data_out)
  );
  assign io_cpu_addr_ready = 1'h0;
  assign io_dram_data_ready = 1'h0;
  assign io_cache_data_0_valid = 1'h0;
  assign io_cache_data_0_bits = test0;
  assign io_cache_data_1_valid = 1'h0;
  assign io_cache_data_1_bits = test1;
  assign io_cache_addr_valid = 1'h0;
  assign io_cache_addr_bits = 32'h0;
endmodule

