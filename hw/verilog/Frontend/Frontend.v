// Generated by CIRCT firtool-1.62.0
// VCS coverage exclude_file
module mem_64x2(
  input  [5:0] R0_addr,
  input        R0_en,
               R0_clk,
  output [1:0] R0_data,
  input  [5:0] W0_addr,
  input        W0_en,
               W0_clk,
  input  [1:0] W0_data
);

  reg [1:0] Memory[0:63];
  reg       _R0_en_d0;
  reg [5:0] _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 2'bx;
endmodule

module SDPReadWriteSmem(
  input        clock,
               reset,
  input  [5:0] io_rd_addr,
  output [1:0] io_data_out,
  input  [5:0] io_wr_addr,
  input        io_wr_en,
  input  [1:0] io_data_in
);

  wire [1:0] _mem_ext_R0_data;
  reg        hazard_reg;
  reg  [1:0] din_buff;
  always @(posedge clock) begin
    if (reset) begin
      hazard_reg <= 1'h0;
      din_buff <= 2'h0;
    end
    else begin
      hazard_reg <= io_rd_addr == io_wr_addr & io_wr_en;
      din_buff <= io_data_in;
    end
  end // always @(posedge)
  mem_64x2 mem_ext (
    .R0_addr (io_rd_addr),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_mem_ext_R0_data),
    .W0_addr (io_wr_addr),
    .W0_en   (io_wr_en),
    .W0_clk  (clock),
    .W0_data (io_data_in)
  );
  assign io_data_out = hazard_reg ? din_buff : _mem_ext_R0_data;
endmodule

// VCS coverage exclude_file
module ram_64x278(
  input  [5:0]   R0_addr,
  input          R0_en,
                 R0_clk,
  output [277:0] R0_data,
  input  [5:0]   W0_addr,
  input          W0_en,
                 W0_clk,
  input  [277:0] W0_data
);

  reg [277:0] Memory[0:63];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 278'bx;
endmodule

module ReadWriteSmem(
  input          clock,
                 io_wr_en,
  input  [5:0]   io_addr,
  input  [277:0] io_data_in,
  output [277:0] io_data_out
);

  wire [277:0] _ram_ext_R0_data;
  reg  [277:0] dataOut;
  always @(posedge clock)
    dataOut <= _ram_ext_R0_data;
  ram_64x278 ram_ext (
    .R0_addr (io_addr),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (io_addr),
    .W0_en   (io_wr_en),
    .W0_clk  (clock),
    .W0_data (io_data_in)
  );
  assign io_data_out = dataOut;
endmodule

module instruction_validator(
  input  [1:0] io_instruction_index,
  output [3:0] io_instruction_output
);

  wire [3:0][3:0] _GEN = '{4'h1, 4'h3, 4'h7, 4'hF};
  assign io_instruction_output = _GEN[io_instruction_index];
endmodule

module L1_instruction_cache(
  input          clock,
                 reset,
  output         io_cpu_addr_ready,
  input          io_cpu_addr_valid,
  input  [31:0]  io_cpu_addr_bits,
  output         io_dram_data_ready,
  input          io_dram_data_valid,
  input  [255:0] io_dram_data_bits,
  input          io_kill,
  output         io_cache_data_valid,
  output [31:0]  io_cache_data_bits_fetch_PC,
                 io_cache_data_bits_instructions_0,
                 io_cache_data_bits_instructions_1,
                 io_cache_data_bits_instructions_2,
                 io_cache_data_bits_instructions_3,
  output         io_cache_data_bits_valid_bits_0,
                 io_cache_data_bits_valid_bits_1,
                 io_cache_data_bits_valid_bits_2,
                 io_cache_data_bits_valid_bits_3,
  input          io_cache_addr_ready,
  output         io_cache_addr_valid,
  output [31:0]  io_cache_addr_bits
);

  wire             miss;
  wire [1:0]       hit_oh;
  wire [29:0]      current_addr;
  wire [3:0]       _validator_io_instruction_output;
  wire [277:0]     _data_memory_1_io_data_out;
  wire [277:0]     _data_memory_0_io_data_out;
  wire [1:0]       _LRU_memory_io_data_out;
  wire [31:0]      dram_addr_mask = 32'hFFFFFFE0;
  reg  [1:0]       cache_state;
  reg  [31:0]      replay_addr;
  reg  [20:0]      replay_tag;
  reg              replay_valid;
  reg  [31:0]      fetch_PC_buf;
  reg              packet_index;
  wire [20:0]      current_addr_tag = current_addr[29:9];
  wire [5:0]       current_addr_set = current_addr[8:3];
  wire             current_addr_fetch_packet = current_addr[2];
  wire [2:0]       current_addr_instruction_offset = current_addr[2:0];
  reg  [20:0]      replay_tag_REG;
  wire             _GEN = miss & ~io_kill;
  reg  [31:0]      io_cache_addr_bits_REG;
  wire             _GEN_0 = cache_state == 2'h1;
  assign current_addr =
    (|cache_state) | miss ? replay_addr[31:2] : io_cpu_addr_bits[31:2];
  wire [277:0]     current_data = {1'h1, replay_tag, io_dram_data_bits};
  reg  [5:0]       LRU_memory_io_wr_addr_REG;
  wire [1:0]       allocate_way =
    _LRU_memory_io_data_out[1] ? {1'h0, ~(_LRU_memory_io_data_out[0])} : 2'h2;
  reg  [20:0]      hit_oh_vec_0_REG;
  wire             hit_oh_vec_0 =
    _data_memory_0_io_data_out[276:256] == hit_oh_vec_0_REG
    & _data_memory_0_io_data_out[277];
  reg  [20:0]      hit_oh_vec_1_REG;
  wire             hit_oh_vec_1 =
    _data_memory_1_io_data_out[276:256] == hit_oh_vec_1_REG
    & _data_memory_1_io_data_out[277];
  assign hit_oh = {hit_oh_vec_1, hit_oh_vec_0};
  reg              hit_REG;
  reg              hit_REG_1;
  reg              hit_REG_2;
  reg              hit_REG_3;
  wire             hit = (|hit_oh) & (hit_REG | hit_REG_1) & ~hit_REG_2 & ~hit_REG_3;
  reg              miss_REG;
  reg              miss_REG_1;
  reg              miss_REG_2;
  reg              miss_REG_3;
  assign miss = ~(|hit_oh) & (miss_REG | miss_REG_1) & ~miss_REG_2 & ~miss_REG_3;
  wire [255:0]     hit_instruction_data =
    hit_oh_vec_1
      ? _data_memory_1_io_data_out[255:0]
      : hit_oh_vec_0 ? _data_memory_0_io_data_out[255:0] : 256'h0;
  wire [7:0][31:0] _GEN_1 =
    {{hit_instruction_data[31:0]},
     {hit_instruction_data[63:32]},
     {hit_instruction_data[95:64]},
     {hit_instruction_data[127:96]},
     {hit_instruction_data[159:128]},
     {hit_instruction_data[191:160]},
     {hit_instruction_data[223:192]},
     {hit_instruction_data[255:224]}};
  wire [2:0]       _GEN_2 = {packet_index, 2'h0};
  reg              io_cache_data_bits_valid_bits_0_REG;
  reg              io_cache_data_bits_valid_bits_1_REG;
  reg              io_cache_data_bits_valid_bits_2_REG;
  reg              io_cache_data_bits_valid_bits_3_REG;
  always @(posedge clock) begin
    if (reset) begin
      cache_state <= 2'h0;
      replay_addr <= 32'h0;
      replay_tag <= 21'h0;
      replay_valid <= 1'h0;
      fetch_PC_buf <= 32'h0;
      packet_index <= 1'h0;
    end
    else begin
      automatic logic _GEN_3;
      _GEN_3 = cache_state == 2'h2;
      if (|cache_state) begin
        if (_GEN_0) begin
          if (io_kill)
            cache_state <= 2'h0;
          else if (io_dram_data_valid)
            cache_state <= 2'h2;
        end
        else if (_GEN_3)
          cache_state <= 2'h0;
      end
      else begin
        if (_GEN)
          cache_state <= 2'h1;
        replay_tag <= replay_tag_REG;
      end
      if (io_cpu_addr_valid)
        replay_addr <= io_cpu_addr_bits;
      replay_valid <=
        (|cache_state)
        & (_GEN_0 ? ~io_kill & io_dram_data_valid : ~_GEN_3 & replay_valid);
      if (~(|cache_state) & ~miss) begin
        fetch_PC_buf <= io_cpu_addr_bits;
        packet_index <= current_addr_fetch_packet;
      end
    end
    replay_tag_REG <= io_cpu_addr_bits[31:11];
    io_cache_addr_bits_REG <= io_cpu_addr_bits;
    LRU_memory_io_wr_addr_REG <= current_addr_set;
    hit_oh_vec_0_REG <= current_addr_tag;
    hit_oh_vec_1_REG <= current_addr_tag;
    hit_REG <= io_cpu_addr_valid;
    hit_REG_1 <= replay_valid;
    hit_REG_2 <= io_kill;
    hit_REG_3 <= reset;
    miss_REG <= io_cpu_addr_valid;
    miss_REG_1 <= replay_valid;
    miss_REG_2 <= io_kill;
    miss_REG_3 <= reset;
    io_cache_data_bits_valid_bits_0_REG <= _validator_io_instruction_output[3];
    io_cache_data_bits_valid_bits_1_REG <= _validator_io_instruction_output[2];
    io_cache_data_bits_valid_bits_2_REG <= _validator_io_instruction_output[1];
    io_cache_data_bits_valid_bits_3_REG <= _validator_io_instruction_output[0];
  end // always @(posedge)
  SDPReadWriteSmem LRU_memory (
    .clock       (clock),
    .reset       (reset),
    .io_rd_addr  (current_addr_set),
    .io_data_out (_LRU_memory_io_data_out),
    .io_wr_addr  (LRU_memory_io_wr_addr_REG),
    .io_wr_en    (hit),
    .io_data_in
      ({2{(_LRU_memory_io_data_out | hit_oh) != 2'h3}} & _LRU_memory_io_data_out | hit_oh)
  );
  ReadWriteSmem data_memory_0 (
    .clock       (clock),
    .io_wr_en    (io_dram_data_valid & allocate_way[0]),
    .io_addr     (current_addr_set),
    .io_data_in  (current_data),
    .io_data_out (_data_memory_0_io_data_out)
  );
  ReadWriteSmem data_memory_1 (
    .clock       (clock),
    .io_wr_en    (io_dram_data_valid & allocate_way[1]),
    .io_addr     (current_addr_set),
    .io_data_in  (current_data),
    .io_data_out (_data_memory_1_io_data_out)
  );
  instruction_validator validator (
    .io_instruction_index  (current_addr_instruction_offset[1:0]),
    .io_instruction_output (_validator_io_instruction_output)
  );
  assign io_cpu_addr_ready = ~(|cache_state) & ~miss;
  assign io_dram_data_ready =
    (|cache_state) ? _GEN_0 & (io_kill | ~io_dram_data_valid) : _GEN;
  assign io_cache_data_valid = hit & ~io_kill;
  assign io_cache_data_bits_fetch_PC = fetch_PC_buf;
  assign io_cache_data_bits_instructions_0 = _GEN_1[{packet_index, 2'h0}];
  assign io_cache_data_bits_instructions_1 = _GEN_1[_GEN_2 + 3'h1];
  assign io_cache_data_bits_instructions_2 = _GEN_1[_GEN_2 + 3'h2];
  assign io_cache_data_bits_instructions_3 = _GEN_1[_GEN_2 + 3'h3];
  assign io_cache_data_bits_valid_bits_0 =
    io_cache_data_bits_valid_bits_0_REG & hit & ~io_kill;
  assign io_cache_data_bits_valid_bits_1 =
    io_cache_data_bits_valid_bits_1_REG & hit & ~io_kill;
  assign io_cache_data_bits_valid_bits_2 =
    io_cache_data_bits_valid_bits_2_REG & hit & ~io_kill;
  assign io_cache_data_bits_valid_bits_3 =
    io_cache_data_bits_valid_bits_3_REG & hit & ~io_kill;
  assign io_cache_addr_valid = ~(|cache_state) & _GEN;
  assign io_cache_addr_bits =
    ~(|cache_state) & _GEN ? io_cache_addr_bits_REG & dram_addr_mask : 32'h0;
endmodule

// VCS coverage exclude_file
module mem_65536x2(
  input  [15:0] R0_addr,
  input         R0_en,
                R0_clk,
  output [1:0]  R0_data,
  input  [15:0] R1_addr,
  input         R1_en,
                R1_clk,
  output [1:0]  R1_data,
  input  [15:0] W0_addr,
  input         W0_en,
                W0_clk,
  input  [1:0]  W0_data
);

  reg [1:0]  Memory[0:65535];
  reg        _R0_en_d0;
  reg [15:0] _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  reg        _R1_en_d0;
  reg [15:0] _R1_addr_d0;
  always @(posedge R1_clk) begin
    _R1_en_d0 <= R1_en;
    _R1_addr_d0 <= R1_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 2'bx;
  assign R1_data = _R1_en_d0 ? Memory[_R1_addr_d0] : 2'bx;
endmodule

module PHT_memory(
  input         clock,
  input  [15:0] io_addrA,
  output [15:0] io_readDataA,
  input  [15:0] io_addrB,
  output [15:0] io_readDataB,
  input  [15:0] io_addrC,
  input  [1:0]  io_writeDataC,
  input         io_writeEnableC
);

  wire [1:0] _mem_ext_R0_data;
  wire [1:0] _mem_ext_R1_data;
  mem_65536x2 mem_ext (
    .R0_addr (io_addrB),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_mem_ext_R0_data),
    .R1_addr (io_addrA),
    .R1_en   (1'h1),
    .R1_clk  (clock),
    .R1_data (_mem_ext_R1_data),
    .W0_addr (io_addrC),
    .W0_en   (io_writeEnableC),
    .W0_clk  (clock),
    .W0_data (io_writeDataC)
  );
  assign io_readDataA = {14'h0, _mem_ext_R1_data};
  assign io_readDataB = {14'h0, _mem_ext_R0_data};
endmodule

module gshare(
  input         clock,
  input  [15:0] io_predict_GHR,
  input  [31:0] io_predict_PC,
  input         io_predict_valid,
  output        io_T_NT,
                io_valid,
  input  [15:0] io_commit_GHR,
  input  [31:0] io_commit_PC,
  input         io_commit_valid,
                io_commit_branch_direction
);

  wire [15:0] _PHT_io_readDataA;
  wire [15:0] _PHT_io_readDataB;
  wire [15:0] hashed_predict_addr = io_predict_PC[15:0] ^ io_predict_GHR;
  wire [15:0] hashed_commit_addr = io_commit_PC[15:0] ^ io_commit_GHR;
  reg         io_valid_REG;
  reg  [15:0] PHT_io_addrC_REG;
  reg         PHT_io_writeEnableC_REG;
  reg         REG;
  always @(posedge clock) begin
    io_valid_REG <= io_predict_valid;
    PHT_io_addrC_REG <= hashed_commit_addr;
    PHT_io_writeEnableC_REG <= io_commit_valid;
    REG <= io_commit_branch_direction;
  end // always @(posedge)
  PHT_memory PHT (
    .clock           (clock),
    .io_addrA        (hashed_predict_addr),
    .io_readDataA    (_PHT_io_readDataA),
    .io_addrB        (hashed_commit_addr),
    .io_readDataB    (_PHT_io_readDataB),
    .io_addrC        (PHT_io_addrC_REG),
    .io_writeDataC
      (REG
         ? (_PHT_io_readDataB[1:0] != 2'h3
              ? _PHT_io_readDataB[1:0] + 2'h1
              : _PHT_io_readDataB[1:0])
         : (|(_PHT_io_readDataB[1:0]))
             ? _PHT_io_readDataB[1:0] - 2'h1
             : _PHT_io_readDataB[1:0]),
    .io_writeEnableC (PHT_io_writeEnableC_REG)
  );
  assign io_T_NT = _PHT_io_readDataA[1];
  assign io_valid = io_valid_REG;
endmodule

// VCS coverage exclude_file
module mem_4096x55(
  input  [11:0] R0_addr,
  input         R0_en,
                R0_clk,
  output [54:0] R0_data,
  input  [11:0] W0_addr,
  input         W0_en,
                W0_clk,
  input  [54:0] W0_data
);

  reg [54:0] Memory[0:4095];
  reg        _R0_en_d0;
  reg [11:0] _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 55'bx;
endmodule

module SDPReadWriteSmem_1(
  input         clock,
                reset,
  input  [11:0] io_rd_addr,
  output [54:0] io_data_out,
  input  [11:0] io_wr_addr,
  input         io_wr_en,
  input  [54:0] io_data_in
);

  wire [54:0] _mem_ext_R0_data;
  reg         hazard_reg;
  reg  [54:0] din_buff;
  always @(posedge clock) begin
    if (reset) begin
      hazard_reg <= 1'h0;
      din_buff <= 55'h0;
    end
    else begin
      hazard_reg <= io_rd_addr == io_wr_addr & io_wr_en;
      din_buff <= io_data_in;
    end
  end // always @(posedge)
  mem_4096x55 mem_ext (
    .R0_addr (io_rd_addr),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_mem_ext_R0_data),
    .W0_addr (io_wr_addr),
    .W0_en   (io_wr_en),
    .W0_clk  (clock),
    .W0_data (io_data_in)
  );
  assign io_data_out = hazard_reg ? din_buff : _mem_ext_R0_data;
endmodule

module hash_BTB(
  input         clock,
                reset,
  input  [31:0] io_predict_PC,
  input         io_predict_valid,
  output        io_BTB_valid,
  output [31:0] io_BTB_target,
  output [1:0]  io_BTB_type,
  output [3:0]  io_BTB_br_mask,
  output        io_BTB_hit,
  input  [31:0] io_commit_PC,
                io_commit_target,
  input  [1:0]  io_commit_br_type,
  input  [3:0]  io_commit_br_mask,
  input         io_commit_valid
);

  wire [54:0] _BTB_memory_io_data_out;
  wire [15:0] commit_input_tag = io_commit_PC[31:16];
  wire [15:0] BTB_tag_output = _BTB_memory_io_data_out[53:38];
  reg         io_BTB_valid_REG;
  reg  [15:0] io_BTB_hit_REG;
  always @(posedge clock) begin
    io_BTB_valid_REG <= io_predict_valid;
    io_BTB_hit_REG <= io_predict_PC[31:16];
  end // always @(posedge)
  SDPReadWriteSmem_1 BTB_memory (
    .clock       (clock),
    .reset       (reset),
    .io_rd_addr  (io_predict_PC[15:4]),
    .io_data_out (_BTB_memory_io_data_out),
    .io_wr_addr  (io_commit_PC[15:4]),
    .io_wr_en    (io_commit_valid),
    .io_data_in
      ({1'h1, commit_input_tag, io_commit_target, io_commit_br_type, io_commit_br_mask})
  );
  assign io_BTB_valid = io_BTB_valid_REG;
  assign io_BTB_target = _BTB_memory_io_data_out[37:6];
  assign io_BTB_type = _BTB_memory_io_data_out[5:4];
  assign io_BTB_br_mask = _BTB_memory_io_data_out[3:0];
  assign io_BTB_hit = io_BTB_hit_REG == BTB_tag_output & _BTB_memory_io_data_out[54];
endmodule

// VCS coverage exclude_file
module mem_128x39(
  input  [6:0]  R0_addr,
  input         R0_en,
                R0_clk,
  output [38:0] R0_data,
  input  [6:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [38:0] W0_data
);

  reg [38:0] Memory[0:127];
  reg        _R0_en_d0;
  reg [6:0]  _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 39'bx;
endmodule

module SDPReadWriteSmem_2(
  input         clock,
                reset,
  input  [6:0]  io_rd_addr,
  output [38:0] io_data_out,
  input  [6:0]  io_wr_addr,
  input         io_wr_en,
  input  [38:0] io_data_in
);

  wire [38:0] _mem_ext_R0_data;
  reg         hazard_reg;
  reg  [38:0] din_buff;
  always @(posedge clock) begin
    if (reset) begin
      hazard_reg <= 1'h0;
      din_buff <= 39'h0;
    end
    else begin
      hazard_reg <= io_rd_addr == io_wr_addr & io_wr_en;
      din_buff <= io_data_in;
    end
  end // always @(posedge)
  mem_128x39 mem_ext (
    .R0_addr (io_rd_addr),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_mem_ext_R0_data),
    .W0_addr (io_wr_addr),
    .W0_en   (io_wr_en),
    .W0_clk  (clock),
    .W0_data (io_data_in)
  );
  assign io_data_out = hazard_reg ? din_buff : _mem_ext_R0_data;
endmodule

module RAS(
  input         clock,
                reset,
  input  [31:0] io_wr_addr,
  input         io_wr_valid,
                io_rd_valid,
  input  [6:0]  io_revert_NEXT,
                io_revert_TOS,
  input         io_revert_valid,
  output [31:0] io_ret_addr
);

  wire [6:0]  NOS;
  wire [38:0] _RAS_memory_io_data_out;
  reg  [6:0]  NEXT;
  reg  [6:0]  TOS;
  assign NOS = _RAS_memory_io_data_out[38:32];
  always @(posedge clock) begin
    if (reset) begin
      NEXT <= 7'h0;
      TOS <= 7'h0;
    end
    else if (io_revert_valid) begin
      NEXT <= io_revert_NEXT;
      TOS <= io_revert_TOS;
    end
    else if (io_wr_valid) begin
      NEXT <= NEXT + 7'h1;
      TOS <= NEXT;
    end
    else if (io_rd_valid)
      TOS <= NOS;
  end // always @(posedge)
  SDPReadWriteSmem_2 RAS_memory (
    .clock       (clock),
    .reset       (reset),
    .io_rd_addr
      (io_wr_valid ? NEXT : io_rd_valid ? NOS : io_revert_valid ? io_revert_TOS : TOS),
    .io_data_out (_RAS_memory_io_data_out),
    .io_wr_addr  (NEXT),
    .io_wr_en    (io_wr_valid),
    .io_data_in  ({TOS, io_wr_addr})
  );
  assign io_ret_addr = _RAS_memory_io_data_out[31:0];
endmodule

module BP(
  input         clock,
                reset,
                io_predict_valid,
  input  [31:0] io_predict_bits,
  input         io_commit_valid,
  input  [31:0] io_commit_bits_PC,
  input  [15:0] io_commit_bits_GHR,
  input         io_commit_bits_T_NT,
  input  [31:0] io_commit_bits_target,
  input  [1:0]  io_commit_bits_br_type,
  input  [3:0]  io_commit_bits_br_mask,
  input         io_commit_bits_misprediction,
  input  [6:0]  io_commit_bits_TOS,
                io_commit_bits_NEXT,
  input  [31:0] io_RAS_update_call_addr,
  input         io_RAS_update_call,
                io_RAS_update_ret,
  output [31:0] io_RAS_read_ret_addr,
  input         io_revert_valid,
  input  [15:0] io_revert_bits_GHR,
  output        io_prediction_valid,
                io_prediction_bits_hit,
  output [31:0] io_prediction_bits_target,
  output [1:0]  io_prediction_bits_br_type,
  output [3:0]  io_prediction_bits_br_mask,
  output [15:0] io_prediction_bits_GHR,
  output        io_prediction_bits_T_NT
);

  wire        _BTB_io_BTB_valid;
  wire [1:0]  _BTB_io_BTB_type;
  wire        _BTB_io_BTB_hit;
  wire        _gshare_io_T_NT;
  wire        _gshare_io_valid;
  wire        revert = io_revert_valid;
  wire        otherwise = 1'h0;
  reg  [15:0] GHR_reg;
  wire        misprediction = io_commit_valid & io_commit_bits_misprediction;
  wire        GHR_update =
    _gshare_io_valid & _BTB_io_BTB_valid & _BTB_io_BTB_hit & _BTB_io_BTB_type == 2'h0;
  wire [15:0] _GEN = {GHR_reg[14:0], _gshare_io_T_NT};
  wire        update_PHT = io_commit_bits_br_type == 2'h0 & io_commit_valid;
  always @(posedge clock) begin
    if (reset)
      GHR_reg <= 16'h0;
    else if (misprediction)
      GHR_reg <= io_commit_bits_GHR;
    else if (revert)
      GHR_reg <= io_revert_bits_GHR;
    else if (GHR_update)
      GHR_reg <= _GEN;
  end // always @(posedge)
  gshare gshare (
    .clock                      (clock),
    .io_predict_GHR
      (misprediction
         ? io_commit_bits_GHR
         : revert ? io_revert_bits_GHR : GHR_update ? _GEN : GHR_reg),
    .io_predict_PC              (io_predict_bits),
    .io_predict_valid           (io_predict_valid),
    .io_T_NT                    (_gshare_io_T_NT),
    .io_valid                   (_gshare_io_valid),
    .io_commit_GHR              (io_commit_bits_GHR),
    .io_commit_PC               (io_commit_bits_PC),
    .io_commit_valid            (update_PHT),
    .io_commit_branch_direction (io_commit_bits_T_NT)
  );
  hash_BTB BTB (
    .clock             (clock),
    .reset             (reset),
    .io_predict_PC     (io_predict_bits),
    .io_predict_valid  (io_predict_valid),
    .io_BTB_valid      (_BTB_io_BTB_valid),
    .io_BTB_target     (io_prediction_bits_target),
    .io_BTB_type       (_BTB_io_BTB_type),
    .io_BTB_br_mask    (io_prediction_bits_br_mask),
    .io_BTB_hit        (_BTB_io_BTB_hit),
    .io_commit_PC      (io_commit_bits_PC),
    .io_commit_target  (io_commit_bits_target),
    .io_commit_br_type (io_commit_bits_br_type),
    .io_commit_br_mask (io_commit_bits_br_mask),
    .io_commit_valid   (io_commit_bits_T_NT & io_commit_valid)
  );
  RAS RAS (
    .clock           (clock),
    .reset           (reset),
    .io_wr_addr      (io_RAS_update_call_addr),
    .io_wr_valid     (io_RAS_update_call & ~misprediction),
    .io_rd_valid     (io_RAS_update_ret & ~misprediction),
    .io_revert_NEXT  (io_commit_bits_NEXT),
    .io_revert_TOS   (io_commit_bits_TOS),
    .io_revert_valid (misprediction),
    .io_ret_addr     (io_RAS_read_ret_addr)
  );
  assign io_prediction_valid = _BTB_io_BTB_valid & _gshare_io_valid;
  assign io_prediction_bits_hit = _BTB_io_BTB_hit;
  assign io_prediction_bits_br_type = _BTB_io_BTB_type;
  assign io_prediction_bits_GHR = GHR_reg;
  assign io_prediction_bits_T_NT = _gshare_io_T_NT;
endmodule

module branch_decoder(
  input  [31:0] io_fetch_PC,
                io_instruction,
  input         io_valid,
                io_prediction_bits_hit,
  input  [31:0] io_prediction_bits_target,
  input  [3:0]  io_prediction_bits_br_mask,
  input  [31:0] io_RAS_read_ret_addr,
  output        io_T_NT,
                io_metadata_JAL,
                io_metadata_JALR,
                io_metadata_BR,
                io_metadata_Call,
                io_metadata_Ret,
  output [31:0] io_metadata_Imm,
                io_metadata_instruction_PC,
                io_metadata_RAS,
                io_metadata_BTB_target
);

  wire [31:0] imm;
  wire        JAL = io_instruction[6:0] == 7'h6F;
  wire        JALR = io_instruction[6:0] == 7'h67;
  wire        BR = io_instruction[6:0] == 7'h63;
  wire        _Call_T_2 = io_instruction[11:7] == 5'h1;
  wire        Ret = JALR & io_instruction[19:15] == 5'h1 & imm[20:0] == 21'h0;
  assign imm =
    BR
      ? {19'h0,
         io_instruction[31],
         io_instruction[7],
         io_instruction[30:25],
         io_instruction[11:8],
         1'h0}
      : JAL
          ? {11'h0,
             io_instruction[31],
             io_instruction[19:12],
             io_instruction[20],
             io_instruction[30:21],
             1'h0}
          : JALR ? {20'h0, io_instruction[31:20]} : 32'h0;
  assign io_T_NT =
    JAL
      ? io_valid
      : JALR
          ? io_valid & (Ret | io_prediction_bits_hit & io_prediction_bits_br_mask[0])
          : BR & io_valid & io_prediction_bits_br_mask[0];
  assign io_metadata_JAL = JAL;
  assign io_metadata_JALR = JALR;
  assign io_metadata_BR = BR;
  assign io_metadata_Call = JAL & _Call_T_2 | JALR & _Call_T_2;
  assign io_metadata_Ret = Ret;
  assign io_metadata_Imm = imm;
  assign io_metadata_instruction_PC = io_fetch_PC;
  assign io_metadata_RAS = io_RAS_read_ret_addr;
  assign io_metadata_BTB_target = io_prediction_bits_target;
endmodule

module branch_decoder_1(
  input  [31:0] io_fetch_PC,
                io_instruction,
  input         io_valid,
                io_prediction_bits_hit,
  input  [31:0] io_prediction_bits_target,
  input  [3:0]  io_prediction_bits_br_mask,
  input  [31:0] io_RAS_read_ret_addr,
  output        io_T_NT,
                io_metadata_JAL,
                io_metadata_JALR,
                io_metadata_BR,
                io_metadata_Call,
                io_metadata_Ret,
  output [31:0] io_metadata_Imm,
                io_metadata_instruction_PC,
                io_metadata_RAS,
                io_metadata_BTB_target
);

  wire [31:0] imm;
  wire        JAL = io_instruction[6:0] == 7'h6F;
  wire        JALR = io_instruction[6:0] == 7'h67;
  wire        BR = io_instruction[6:0] == 7'h63;
  wire        _Call_T_2 = io_instruction[11:7] == 5'h1;
  wire        Ret = JALR & io_instruction[19:15] == 5'h1 & imm[20:0] == 21'h0;
  assign imm =
    BR
      ? {19'h0,
         io_instruction[31],
         io_instruction[7],
         io_instruction[30:25],
         io_instruction[11:8],
         1'h0}
      : JAL
          ? {11'h0,
             io_instruction[31],
             io_instruction[19:12],
             io_instruction[20],
             io_instruction[30:21],
             1'h0}
          : JALR ? {20'h0, io_instruction[31:20]} : 32'h0;
  assign io_T_NT =
    JAL
      ? io_valid
      : JALR
          ? io_valid & (Ret | io_prediction_bits_hit & io_prediction_bits_br_mask[1])
          : BR & io_valid & io_prediction_bits_br_mask[1];
  assign io_metadata_JAL = JAL;
  assign io_metadata_JALR = JALR;
  assign io_metadata_BR = BR;
  assign io_metadata_Call = JAL & _Call_T_2 | JALR & _Call_T_2;
  assign io_metadata_Ret = Ret;
  assign io_metadata_Imm = imm;
  assign io_metadata_instruction_PC = io_fetch_PC + 32'h4;
  assign io_metadata_RAS = io_RAS_read_ret_addr;
  assign io_metadata_BTB_target = io_prediction_bits_target;
endmodule

module branch_decoder_2(
  input  [31:0] io_fetch_PC,
                io_instruction,
  input         io_valid,
                io_prediction_bits_hit,
  input  [31:0] io_prediction_bits_target,
  input  [3:0]  io_prediction_bits_br_mask,
  input  [31:0] io_RAS_read_ret_addr,
  output        io_T_NT,
                io_metadata_JAL,
                io_metadata_JALR,
                io_metadata_BR,
                io_metadata_Call,
                io_metadata_Ret,
  output [31:0] io_metadata_Imm,
                io_metadata_instruction_PC,
                io_metadata_RAS,
                io_metadata_BTB_target
);

  wire [31:0] imm;
  wire        JAL = io_instruction[6:0] == 7'h6F;
  wire        JALR = io_instruction[6:0] == 7'h67;
  wire        BR = io_instruction[6:0] == 7'h63;
  wire        _Call_T_2 = io_instruction[11:7] == 5'h1;
  wire        Ret = JALR & io_instruction[19:15] == 5'h1 & imm[20:0] == 21'h0;
  assign imm =
    BR
      ? {19'h0,
         io_instruction[31],
         io_instruction[7],
         io_instruction[30:25],
         io_instruction[11:8],
         1'h0}
      : JAL
          ? {11'h0,
             io_instruction[31],
             io_instruction[19:12],
             io_instruction[20],
             io_instruction[30:21],
             1'h0}
          : JALR ? {20'h0, io_instruction[31:20]} : 32'h0;
  assign io_T_NT =
    JAL
      ? io_valid
      : JALR
          ? io_valid & (Ret | io_prediction_bits_hit & io_prediction_bits_br_mask[2])
          : BR & io_valid & io_prediction_bits_br_mask[2];
  assign io_metadata_JAL = JAL;
  assign io_metadata_JALR = JALR;
  assign io_metadata_BR = BR;
  assign io_metadata_Call = JAL & _Call_T_2 | JALR & _Call_T_2;
  assign io_metadata_Ret = Ret;
  assign io_metadata_Imm = imm;
  assign io_metadata_instruction_PC = io_fetch_PC + 32'h8;
  assign io_metadata_RAS = io_RAS_read_ret_addr;
  assign io_metadata_BTB_target = io_prediction_bits_target;
endmodule

module branch_decoder_3(
  input  [31:0] io_fetch_PC,
                io_instruction,
  input         io_valid,
                io_prediction_bits_hit,
  input  [31:0] io_prediction_bits_target,
  input  [3:0]  io_prediction_bits_br_mask,
  input  [31:0] io_RAS_read_ret_addr,
  output        io_T_NT,
                io_metadata_JAL,
                io_metadata_JALR,
                io_metadata_BR,
                io_metadata_Call,
                io_metadata_Ret,
  output [31:0] io_metadata_Imm,
                io_metadata_instruction_PC,
                io_metadata_RAS,
                io_metadata_BTB_target
);

  wire [31:0] imm;
  wire        JAL = io_instruction[6:0] == 7'h6F;
  wire        JALR = io_instruction[6:0] == 7'h67;
  wire        BR = io_instruction[6:0] == 7'h63;
  wire        _Call_T_2 = io_instruction[11:7] == 5'h1;
  wire        Ret = JALR & io_instruction[19:15] == 5'h1 & imm[20:0] == 21'h0;
  assign imm =
    BR
      ? {19'h0,
         io_instruction[31],
         io_instruction[7],
         io_instruction[30:25],
         io_instruction[11:8],
         1'h0}
      : JAL
          ? {11'h0,
             io_instruction[31],
             io_instruction[19:12],
             io_instruction[20],
             io_instruction[30:21],
             1'h0}
          : JALR ? {20'h0, io_instruction[31:20]} : 32'h0;
  assign io_T_NT =
    JAL
      ? io_valid
      : JALR
          ? io_valid & (Ret | io_prediction_bits_hit & io_prediction_bits_br_mask[3])
          : BR & io_valid & io_prediction_bits_br_mask[3];
  assign io_metadata_JAL = JAL;
  assign io_metadata_JALR = JALR;
  assign io_metadata_BR = BR;
  assign io_metadata_Call = JAL & _Call_T_2 | JALR & _Call_T_2;
  assign io_metadata_Ret = Ret;
  assign io_metadata_Imm = imm;
  assign io_metadata_instruction_PC = io_fetch_PC + 32'hC;
  assign io_metadata_RAS = io_RAS_read_ret_addr;
  assign io_metadata_BTB_target = io_prediction_bits_target;
endmodule

module decoder_validator(
  input  [3:0] io_instruction_T_NT_mask,
  output [3:0] io_instruction_validity
);

  wire [3:0][3:0] _GEN = '{4'hF, 4'h7, 4'h3, 4'h1};
  assign io_instruction_validity =
    _GEN[io_instruction_T_NT_mask[0]
           ? 2'h0
           : io_instruction_T_NT_mask[1] ? 2'h1 : {1'h1, ~(io_instruction_T_NT_mask[2])}];
endmodule

module decode_validate(
  input         clock,
                reset,
  output        io_prediction_ready,
  input         io_prediction_valid,
                io_prediction_bits_hit,
  input  [31:0] io_prediction_bits_target,
  input  [3:0]  io_prediction_bits_br_mask,
  input  [15:0] io_prediction_bits_GHR,
  output        io_fetch_packet_ready,
  input         io_fetch_packet_valid,
  input  [31:0] io_fetch_packet_bits_fetch_PC,
                io_fetch_packet_bits_instructions_0,
                io_fetch_packet_bits_instructions_1,
                io_fetch_packet_bits_instructions_2,
                io_fetch_packet_bits_instructions_3,
  input         io_fetch_packet_bits_valid_bits_0,
                io_fetch_packet_bits_valid_bits_1,
                io_fetch_packet_bits_valid_bits_2,
                io_fetch_packet_bits_valid_bits_3,
  input  [31:0] io_RAS_read_ret_addr,
  output        io_revert_valid,
  output [15:0] io_revert_bits_GHR,
  output [31:0] io_revert_bits_PC,
  input         io_final_fetch_packet_ready,
  output        io_final_fetch_packet_valid,
  output [31:0] io_final_fetch_packet_bits_fetch_PC,
                io_final_fetch_packet_bits_instructions_0,
                io_final_fetch_packet_bits_instructions_1,
                io_final_fetch_packet_bits_instructions_2,
                io_final_fetch_packet_bits_instructions_3,
  output        io_final_fetch_packet_bits_valid_bits_0,
                io_final_fetch_packet_bits_valid_bits_1,
                io_final_fetch_packet_bits_valid_bits_2,
                io_final_fetch_packet_bits_valid_bits_3,
  output [31:0] io_RAS_update_call_addr,
  output        io_RAS_update_call,
                io_RAS_update_ret
);

  wire [31:0] PC_next;
  wire [31:0] PC_expected;
  wire [3:0]  _decoder_validator_io_instruction_validity;
  wire        _decoders_3_io_T_NT;
  wire        _decoders_3_io_metadata_JAL;
  wire        _decoders_3_io_metadata_JALR;
  wire        _decoders_3_io_metadata_BR;
  wire        _decoders_3_io_metadata_Call;
  wire        _decoders_3_io_metadata_Ret;
  wire [31:0] _decoders_3_io_metadata_Imm;
  wire [31:0] _decoders_3_io_metadata_instruction_PC;
  wire [31:0] _decoders_3_io_metadata_RAS;
  wire [31:0] _decoders_3_io_metadata_BTB_target;
  wire        _decoders_2_io_T_NT;
  wire        _decoders_2_io_metadata_JAL;
  wire        _decoders_2_io_metadata_JALR;
  wire        _decoders_2_io_metadata_BR;
  wire        _decoders_2_io_metadata_Call;
  wire        _decoders_2_io_metadata_Ret;
  wire [31:0] _decoders_2_io_metadata_Imm;
  wire [31:0] _decoders_2_io_metadata_instruction_PC;
  wire [31:0] _decoders_2_io_metadata_RAS;
  wire [31:0] _decoders_2_io_metadata_BTB_target;
  wire        _decoders_1_io_T_NT;
  wire        _decoders_1_io_metadata_JAL;
  wire        _decoders_1_io_metadata_JALR;
  wire        _decoders_1_io_metadata_BR;
  wire        _decoders_1_io_metadata_Call;
  wire        _decoders_1_io_metadata_Ret;
  wire [31:0] _decoders_1_io_metadata_Imm;
  wire [31:0] _decoders_1_io_metadata_instruction_PC;
  wire [31:0] _decoders_1_io_metadata_RAS;
  wire [31:0] _decoders_1_io_metadata_BTB_target;
  wire        _decoders_0_io_T_NT;
  wire        _decoders_0_io_metadata_JAL;
  wire        _decoders_0_io_metadata_JALR;
  wire        _decoders_0_io_metadata_BR;
  wire        _decoders_0_io_metadata_Call;
  wire        _decoders_0_io_metadata_Ret;
  wire [31:0] _decoders_0_io_metadata_Imm;
  wire [31:0] _decoders_0_io_metadata_instruction_PC;
  wire [31:0] _decoders_0_io_metadata_RAS;
  wire [31:0] _decoders_0_io_metadata_BTB_target;
  wire        inputs_valid = io_fetch_packet_valid & io_prediction_valid;
  reg         metadata_reg_0_JAL;
  reg         metadata_reg_0_JALR;
  reg         metadata_reg_0_BR;
  reg         metadata_reg_0_Call;
  reg         metadata_reg_0_Ret;
  reg  [31:0] metadata_reg_0_Imm;
  reg  [31:0] metadata_reg_0_instruction_PC;
  reg  [31:0] metadata_reg_0_RAS;
  reg  [31:0] metadata_reg_0_BTB_target;
  reg         metadata_reg_1_JAL;
  reg         metadata_reg_1_JALR;
  reg         metadata_reg_1_BR;
  reg         metadata_reg_1_Call;
  reg         metadata_reg_1_Ret;
  reg  [31:0] metadata_reg_1_Imm;
  reg  [31:0] metadata_reg_1_instruction_PC;
  reg  [31:0] metadata_reg_1_RAS;
  reg  [31:0] metadata_reg_1_BTB_target;
  reg         metadata_reg_2_JAL;
  reg         metadata_reg_2_JALR;
  reg         metadata_reg_2_BR;
  reg         metadata_reg_2_Call;
  reg         metadata_reg_2_Ret;
  reg  [31:0] metadata_reg_2_Imm;
  reg  [31:0] metadata_reg_2_instruction_PC;
  reg  [31:0] metadata_reg_2_RAS;
  reg  [31:0] metadata_reg_2_BTB_target;
  reg         metadata_reg_3_JAL;
  reg         metadata_reg_3_JALR;
  reg         metadata_reg_3_BR;
  reg         metadata_reg_3_Call;
  reg         metadata_reg_3_Ret;
  reg  [31:0] metadata_reg_3_Imm;
  reg  [31:0] metadata_reg_3_instruction_PC;
  reg  [31:0] metadata_reg_3_RAS;
  reg  [31:0] metadata_reg_3_BTB_target;
  reg         T_NT_reg_1;
  reg         T_NT_reg_2;
  reg         T_NT_reg_3;
  reg  [15:0] GHR_reg;
  wire        use_RAS =
    T_NT_reg_3
      ? metadata_reg_3_Ret
      : T_NT_reg_2
          ? metadata_reg_2_Ret
          : T_NT_reg_1 ? metadata_reg_1_Ret : metadata_reg_0_Ret;
  wire [31:0] metadata_out_instruction_PC =
    T_NT_reg_3
      ? metadata_reg_3_instruction_PC
      : T_NT_reg_2
          ? metadata_reg_2_instruction_PC
          : T_NT_reg_1 ? metadata_reg_1_instruction_PC : metadata_reg_0_instruction_PC;
  reg  [31:0] PC_next_reg;
  reg         FSM1_state;
  reg         FSM2_state;
  wire        PC_match = PC_expected == io_fetch_packet_bits_fetch_PC & inputs_valid;
  wire        PC_mismatch = PC_expected != io_fetch_packet_bits_fetch_PC & inputs_valid;
  assign PC_expected = FSM1_state ? PC_next_reg : PC_next;
  wire        use_BTB =
    (T_NT_reg_3
       ? metadata_reg_3_JALR
       : T_NT_reg_2
           ? metadata_reg_2_JALR
           : T_NT_reg_1 ? metadata_reg_1_JALR : metadata_reg_0_JALR) & ~use_RAS;
  wire        use_computed =
    (T_NT_reg_3
       ? metadata_reg_3_BR
       : T_NT_reg_2
           ? metadata_reg_2_BR
           : T_NT_reg_1 ? metadata_reg_1_BR : metadata_reg_0_BR)
    | (T_NT_reg_3
         ? metadata_reg_3_JAL
         : T_NT_reg_2
             ? metadata_reg_2_JAL
             : T_NT_reg_1 ? metadata_reg_1_JAL : metadata_reg_0_JAL);
  reg  [31:0] PC_next_REG;
  assign PC_next =
    use_BTB
      ? (T_NT_reg_3
           ? metadata_reg_3_BTB_target
           : T_NT_reg_2
               ? metadata_reg_2_BTB_target
               : T_NT_reg_1 ? metadata_reg_1_BTB_target : metadata_reg_0_BTB_target)
      : use_RAS
          ? (T_NT_reg_3
               ? metadata_reg_3_RAS
               : T_NT_reg_2
                   ? metadata_reg_2_RAS
                   : T_NT_reg_1 ? metadata_reg_1_RAS : metadata_reg_0_RAS)
          : use_computed
              ? metadata_out_instruction_PC
                + (T_NT_reg_3
                     ? metadata_reg_3_Imm
                     : T_NT_reg_2
                         ? metadata_reg_2_Imm
                         : T_NT_reg_1 ? metadata_reg_1_Imm : metadata_reg_0_Imm)
              : PC_next_REG;
  reg  [31:0] test_REG;
  wire [31:0] test = test_REG;
  reg  [31:0] io_final_fetch_packet_bits_instructions_0_REG;
  reg         io_final_fetch_packet_bits_valid_bits_0_REG;
  reg         io_final_fetch_packet_bits_valid_bits_0_REG_1;
  reg  [31:0] io_final_fetch_packet_bits_instructions_1_REG;
  reg         io_final_fetch_packet_bits_valid_bits_1_REG;
  reg         io_final_fetch_packet_bits_valid_bits_1_REG_1;
  reg  [31:0] io_final_fetch_packet_bits_instructions_2_REG;
  reg         io_final_fetch_packet_bits_valid_bits_2_REG;
  reg         io_final_fetch_packet_bits_valid_bits_2_REG_1;
  reg  [31:0] io_final_fetch_packet_bits_instructions_3_REG;
  reg         io_final_fetch_packet_bits_valid_bits_3_REG;
  reg         io_final_fetch_packet_bits_valid_bits_3_REG_1;
  reg  [31:0] io_final_fetch_packet_bits_fetch_PC_REG;
  reg         io_final_fetch_packet_valid_REG;
  always @(posedge clock) begin
    metadata_reg_0_JAL <= _decoders_0_io_metadata_JAL;
    metadata_reg_0_JALR <= _decoders_0_io_metadata_JALR;
    metadata_reg_0_BR <= _decoders_0_io_metadata_BR;
    metadata_reg_0_Call <= _decoders_0_io_metadata_Call;
    metadata_reg_0_Ret <= _decoders_0_io_metadata_Ret;
    metadata_reg_0_Imm <= _decoders_0_io_metadata_Imm;
    metadata_reg_0_instruction_PC <= _decoders_0_io_metadata_instruction_PC;
    metadata_reg_0_RAS <= _decoders_0_io_metadata_RAS;
    metadata_reg_0_BTB_target <= _decoders_0_io_metadata_BTB_target;
    metadata_reg_1_JAL <= _decoders_1_io_metadata_JAL;
    metadata_reg_1_JALR <= _decoders_1_io_metadata_JALR;
    metadata_reg_1_BR <= _decoders_1_io_metadata_BR;
    metadata_reg_1_Call <= _decoders_1_io_metadata_Call;
    metadata_reg_1_Ret <= _decoders_1_io_metadata_Ret;
    metadata_reg_1_Imm <= _decoders_1_io_metadata_Imm;
    metadata_reg_1_instruction_PC <= _decoders_1_io_metadata_instruction_PC;
    metadata_reg_1_RAS <= _decoders_1_io_metadata_RAS;
    metadata_reg_1_BTB_target <= _decoders_1_io_metadata_BTB_target;
    metadata_reg_2_JAL <= _decoders_2_io_metadata_JAL;
    metadata_reg_2_JALR <= _decoders_2_io_metadata_JALR;
    metadata_reg_2_BR <= _decoders_2_io_metadata_BR;
    metadata_reg_2_Call <= _decoders_2_io_metadata_Call;
    metadata_reg_2_Ret <= _decoders_2_io_metadata_Ret;
    metadata_reg_2_Imm <= _decoders_2_io_metadata_Imm;
    metadata_reg_2_instruction_PC <= _decoders_2_io_metadata_instruction_PC;
    metadata_reg_2_RAS <= _decoders_2_io_metadata_RAS;
    metadata_reg_2_BTB_target <= _decoders_2_io_metadata_BTB_target;
    metadata_reg_3_JAL <= _decoders_3_io_metadata_JAL;
    metadata_reg_3_JALR <= _decoders_3_io_metadata_JALR;
    metadata_reg_3_BR <= _decoders_3_io_metadata_BR;
    metadata_reg_3_Call <= _decoders_3_io_metadata_Call;
    metadata_reg_3_Ret <= _decoders_3_io_metadata_Ret;
    metadata_reg_3_Imm <= _decoders_3_io_metadata_Imm;
    metadata_reg_3_instruction_PC <= _decoders_3_io_metadata_instruction_PC;
    metadata_reg_3_RAS <= _decoders_3_io_metadata_RAS;
    metadata_reg_3_BTB_target <= _decoders_3_io_metadata_BTB_target;
    T_NT_reg_1 <= _decoders_1_io_T_NT;
    T_NT_reg_2 <= _decoders_2_io_T_NT;
    T_NT_reg_3 <= _decoders_3_io_T_NT;
    GHR_reg <= io_prediction_bits_GHR;
    PC_next_REG <= io_fetch_packet_bits_fetch_PC + 32'h10;
    test_REG <= io_fetch_packet_bits_fetch_PC + 32'h10;
    io_final_fetch_packet_bits_instructions_0_REG <= io_fetch_packet_bits_instructions_0;
    io_final_fetch_packet_bits_valid_bits_0_REG <=
      _decoder_validator_io_instruction_validity[0];
    io_final_fetch_packet_bits_valid_bits_0_REG_1 <= inputs_valid;
    io_final_fetch_packet_bits_instructions_1_REG <= io_fetch_packet_bits_instructions_1;
    io_final_fetch_packet_bits_valid_bits_1_REG <=
      _decoder_validator_io_instruction_validity[1];
    io_final_fetch_packet_bits_valid_bits_1_REG_1 <= inputs_valid;
    io_final_fetch_packet_bits_instructions_2_REG <= io_fetch_packet_bits_instructions_2;
    io_final_fetch_packet_bits_valid_bits_2_REG <=
      _decoder_validator_io_instruction_validity[2];
    io_final_fetch_packet_bits_valid_bits_2_REG_1 <= inputs_valid;
    io_final_fetch_packet_bits_instructions_3_REG <= io_fetch_packet_bits_instructions_3;
    io_final_fetch_packet_bits_valid_bits_3_REG <=
      _decoder_validator_io_instruction_validity[3];
    io_final_fetch_packet_bits_valid_bits_3_REG_1 <= inputs_valid;
    io_final_fetch_packet_bits_fetch_PC_REG <= io_fetch_packet_bits_fetch_PC;
    io_final_fetch_packet_valid_REG <= inputs_valid;
    if (reset) begin
      PC_next_reg <= 32'h80000000;
      FSM1_state <= 1'h1;
      FSM2_state <= 1'h0;
    end
    else begin
      automatic logic _GEN;
      _GEN = io_prediction_valid & io_fetch_packet_valid;
      if (FSM1_state | _GEN) begin
      end
      else
        PC_next_reg <= PC_next;
      if (FSM1_state)
        FSM1_state <= ~(FSM1_state & _GEN) & FSM1_state;
      else
        FSM1_state <= ~_GEN | FSM1_state;
      if (FSM2_state)
        FSM2_state <= ~(FSM2_state & PC_mismatch) & FSM2_state;
      else
        FSM2_state <= PC_match | FSM2_state;
    end
  end // always @(posedge)
  branch_decoder decoders_0 (
    .io_fetch_PC                (io_fetch_packet_bits_fetch_PC),
    .io_instruction             (io_fetch_packet_bits_instructions_0),
    .io_valid                   (io_fetch_packet_bits_valid_bits_0),
    .io_prediction_bits_hit     (io_prediction_bits_hit),
    .io_prediction_bits_target  (io_prediction_bits_target),
    .io_prediction_bits_br_mask (io_prediction_bits_br_mask),
    .io_RAS_read_ret_addr       (io_RAS_read_ret_addr),
    .io_T_NT                    (_decoders_0_io_T_NT),
    .io_metadata_JAL            (_decoders_0_io_metadata_JAL),
    .io_metadata_JALR           (_decoders_0_io_metadata_JALR),
    .io_metadata_BR             (_decoders_0_io_metadata_BR),
    .io_metadata_Call           (_decoders_0_io_metadata_Call),
    .io_metadata_Ret            (_decoders_0_io_metadata_Ret),
    .io_metadata_Imm            (_decoders_0_io_metadata_Imm),
    .io_metadata_instruction_PC (_decoders_0_io_metadata_instruction_PC),
    .io_metadata_RAS            (_decoders_0_io_metadata_RAS),
    .io_metadata_BTB_target     (_decoders_0_io_metadata_BTB_target)
  );
  branch_decoder_1 decoders_1 (
    .io_fetch_PC                (io_fetch_packet_bits_fetch_PC),
    .io_instruction             (io_fetch_packet_bits_instructions_1),
    .io_valid                   (io_fetch_packet_bits_valid_bits_1),
    .io_prediction_bits_hit     (io_prediction_bits_hit),
    .io_prediction_bits_target  (io_prediction_bits_target),
    .io_prediction_bits_br_mask (io_prediction_bits_br_mask),
    .io_RAS_read_ret_addr       (io_RAS_read_ret_addr),
    .io_T_NT                    (_decoders_1_io_T_NT),
    .io_metadata_JAL            (_decoders_1_io_metadata_JAL),
    .io_metadata_JALR           (_decoders_1_io_metadata_JALR),
    .io_metadata_BR             (_decoders_1_io_metadata_BR),
    .io_metadata_Call           (_decoders_1_io_metadata_Call),
    .io_metadata_Ret            (_decoders_1_io_metadata_Ret),
    .io_metadata_Imm            (_decoders_1_io_metadata_Imm),
    .io_metadata_instruction_PC (_decoders_1_io_metadata_instruction_PC),
    .io_metadata_RAS            (_decoders_1_io_metadata_RAS),
    .io_metadata_BTB_target     (_decoders_1_io_metadata_BTB_target)
  );
  branch_decoder_2 decoders_2 (
    .io_fetch_PC                (io_fetch_packet_bits_fetch_PC),
    .io_instruction             (io_fetch_packet_bits_instructions_2),
    .io_valid                   (io_fetch_packet_bits_valid_bits_2),
    .io_prediction_bits_hit     (io_prediction_bits_hit),
    .io_prediction_bits_target  (io_prediction_bits_target),
    .io_prediction_bits_br_mask (io_prediction_bits_br_mask),
    .io_RAS_read_ret_addr       (io_RAS_read_ret_addr),
    .io_T_NT                    (_decoders_2_io_T_NT),
    .io_metadata_JAL            (_decoders_2_io_metadata_JAL),
    .io_metadata_JALR           (_decoders_2_io_metadata_JALR),
    .io_metadata_BR             (_decoders_2_io_metadata_BR),
    .io_metadata_Call           (_decoders_2_io_metadata_Call),
    .io_metadata_Ret            (_decoders_2_io_metadata_Ret),
    .io_metadata_Imm            (_decoders_2_io_metadata_Imm),
    .io_metadata_instruction_PC (_decoders_2_io_metadata_instruction_PC),
    .io_metadata_RAS            (_decoders_2_io_metadata_RAS),
    .io_metadata_BTB_target     (_decoders_2_io_metadata_BTB_target)
  );
  branch_decoder_3 decoders_3 (
    .io_fetch_PC                (io_fetch_packet_bits_fetch_PC),
    .io_instruction             (io_fetch_packet_bits_instructions_3),
    .io_valid                   (io_fetch_packet_bits_valid_bits_3),
    .io_prediction_bits_hit     (io_prediction_bits_hit),
    .io_prediction_bits_target  (io_prediction_bits_target),
    .io_prediction_bits_br_mask (io_prediction_bits_br_mask),
    .io_RAS_read_ret_addr       (io_RAS_read_ret_addr),
    .io_T_NT                    (_decoders_3_io_T_NT),
    .io_metadata_JAL            (_decoders_3_io_metadata_JAL),
    .io_metadata_JALR           (_decoders_3_io_metadata_JALR),
    .io_metadata_BR             (_decoders_3_io_metadata_BR),
    .io_metadata_Call           (_decoders_3_io_metadata_Call),
    .io_metadata_Ret            (_decoders_3_io_metadata_Ret),
    .io_metadata_Imm            (_decoders_3_io_metadata_Imm),
    .io_metadata_instruction_PC (_decoders_3_io_metadata_instruction_PC),
    .io_metadata_RAS            (_decoders_3_io_metadata_RAS),
    .io_metadata_BTB_target     (_decoders_3_io_metadata_BTB_target)
  );
  decoder_validator decoder_validator (
    .io_instruction_T_NT_mask
      ({_decoders_3_io_T_NT,
        _decoders_2_io_T_NT,
        _decoders_1_io_T_NT,
        _decoders_0_io_T_NT}),
    .io_instruction_validity  (_decoder_validator_io_instruction_validity)
  );
  assign io_prediction_ready = io_final_fetch_packet_ready;
  assign io_fetch_packet_ready = io_final_fetch_packet_ready;
  assign io_revert_valid = PC_mismatch;
  assign io_revert_bits_GHR = GHR_reg;
  assign io_revert_bits_PC = PC_expected;
  assign io_final_fetch_packet_valid = io_final_fetch_packet_valid_REG;
  assign io_final_fetch_packet_bits_fetch_PC = io_final_fetch_packet_bits_fetch_PC_REG;
  assign io_final_fetch_packet_bits_instructions_0 =
    io_final_fetch_packet_bits_instructions_0_REG;
  assign io_final_fetch_packet_bits_instructions_1 =
    io_final_fetch_packet_bits_instructions_1_REG;
  assign io_final_fetch_packet_bits_instructions_2 =
    io_final_fetch_packet_bits_instructions_2_REG;
  assign io_final_fetch_packet_bits_instructions_3 =
    io_final_fetch_packet_bits_instructions_3_REG;
  assign io_final_fetch_packet_bits_valid_bits_0 =
    io_final_fetch_packet_bits_valid_bits_0_REG & FSM2_state
    & io_final_fetch_packet_bits_valid_bits_0_REG_1;
  assign io_final_fetch_packet_bits_valid_bits_1 =
    io_final_fetch_packet_bits_valid_bits_1_REG & FSM2_state
    & io_final_fetch_packet_bits_valid_bits_1_REG_1;
  assign io_final_fetch_packet_bits_valid_bits_2 =
    io_final_fetch_packet_bits_valid_bits_2_REG & FSM2_state
    & io_final_fetch_packet_bits_valid_bits_2_REG_1;
  assign io_final_fetch_packet_bits_valid_bits_3 =
    io_final_fetch_packet_bits_valid_bits_3_REG & FSM2_state
    & io_final_fetch_packet_bits_valid_bits_3_REG_1;
  assign io_RAS_update_call_addr = metadata_out_instruction_PC;
  assign io_RAS_update_call =
    T_NT_reg_3
      ? metadata_reg_3_Call
      : T_NT_reg_2
          ? metadata_reg_2_Call
          : T_NT_reg_1 ? metadata_reg_1_Call : metadata_reg_0_Call;
  assign io_RAS_update_ret = use_RAS;
endmodule

module PC_arbit(
  input         clock,
                reset,
                io_commit_valid,
                io_commit_bits_misprediction,
  input  [31:0] io_commit_bits_misprediction_PC,
  input         io_prediction_valid,
                io_prediction_bits_hit,
  input  [31:0] io_prediction_bits_target,
  input  [1:0]  io_prediction_bits_br_type,
  input         io_revert_valid,
  input  [31:0] io_revert_bits_PC,
                io_RAS_read_ret_addr,
  output        io_PC_next_valid,
  output [31:0] io_PC_next_bits
);

  wire [31:0] io_PC_next_bits_0;
  wire        misprediction;
  reg  [31:0] PC;
  reg  [31:0] correction_address_reg;
  wire        correct_stage_active = misprediction | io_revert_valid;
  assign misprediction = io_commit_valid & io_commit_bits_misprediction;
  wire        is_ret = io_prediction_bits_br_type == 2'h2;
  wire        use_BTB =
    io_prediction_valid & io_prediction_bits_hit & ~is_ret & ~correct_stage_active;
  wire        use_RAS = is_ret & ~correct_stage_active;
  wire [4:0]  PC_increment = {3'h4 - {1'h0, io_PC_next_bits_0[3:2]}, 2'h0};
  reg         REG;
  assign io_PC_next_bits_0 =
    REG
      ? correction_address_reg
      : use_BTB ? io_prediction_bits_target : use_RAS ? io_RAS_read_ret_addr : PC;
  always @(posedge clock) begin
    if (reset) begin
      PC <= 32'h80000000;
      correction_address_reg <= 32'h0;
    end
    else begin
      automatic logic [31:0] correction_address;
      correction_address =
        io_revert_valid
          ? io_revert_bits_PC
          : misprediction ? io_commit_bits_misprediction_PC : 32'h0;
      if (correct_stage_active)
        PC <= correction_address;
      else
        PC <= io_PC_next_bits_0 + {27'h0, PC_increment};
      correction_address_reg <= correction_address;
    end
    REG <= correct_stage_active;
  end // always @(posedge)
  assign io_PC_next_valid = ~correct_stage_active;
  assign io_PC_next_bits = io_PC_next_bits_0;
endmodule

// VCS coverage exclude_file
module ram_16x164(
  input  [3:0]   R0_addr,
  input          R0_en,
                 R0_clk,
  output [163:0] R0_data,
  input  [3:0]   W0_addr,
  input          W0_en,
                 W0_clk,
  input  [163:0] W0_data
);

  reg [163:0] Memory[0:15];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 164'bx;
endmodule

module Queue16_fetch_packet(
  input         clock,
                reset,
                io_enq_valid,
  input  [31:0] io_enq_bits_fetch_PC,
                io_enq_bits_instructions_0,
                io_enq_bits_instructions_1,
                io_enq_bits_instructions_2,
                io_enq_bits_instructions_3,
  input         io_enq_bits_valid_bits_0,
                io_enq_bits_valid_bits_1,
                io_enq_bits_valid_bits_2,
                io_enq_bits_valid_bits_3,
                io_deq_ready,
  output        io_deq_valid,
  output [31:0] io_deq_bits_fetch_PC,
                io_deq_bits_instructions_0,
                io_deq_bits_instructions_1,
                io_deq_bits_instructions_2,
                io_deq_bits_instructions_3,
  output        io_deq_bits_valid_bits_0,
                io_deq_bits_valid_bits_1,
                io_deq_bits_valid_bits_2,
                io_deq_bits_valid_bits_3
);

  wire         io_enq_ready;
  wire [163:0] _ram_ext_R0_data;
  reg  [3:0]   enq_ptr_value;
  reg  [3:0]   deq_ptr_value;
  reg          maybe_full;
  wire         ptr_match = enq_ptr_value == deq_ptr_value;
  wire         empty = ptr_match & ~maybe_full;
  wire         do_enq = io_enq_ready & io_enq_valid;
  assign io_enq_ready = ~(ptr_match & maybe_full);
  always @(posedge clock) begin
    if (reset) begin
      enq_ptr_value <= 4'h0;
      deq_ptr_value <= 4'h0;
      maybe_full <= 1'h0;
    end
    else begin
      automatic logic do_deq = io_deq_ready & ~empty;
      if (do_enq)
        enq_ptr_value <= enq_ptr_value + 4'h1;
      if (do_deq)
        deq_ptr_value <= deq_ptr_value + 4'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge)
  ram_16x164 ram_ext (
    .R0_addr (deq_ptr_value),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (enq_ptr_value),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data
      ({io_enq_bits_valid_bits_3,
        io_enq_bits_valid_bits_2,
        io_enq_bits_valid_bits_1,
        io_enq_bits_valid_bits_0,
        io_enq_bits_instructions_3,
        io_enq_bits_instructions_2,
        io_enq_bits_instructions_1,
        io_enq_bits_instructions_0,
        io_enq_bits_fetch_PC})
  );
  assign io_deq_valid = ~empty;
  assign io_deq_bits_fetch_PC = _ram_ext_R0_data[31:0];
  assign io_deq_bits_instructions_0 = _ram_ext_R0_data[63:32];
  assign io_deq_bits_instructions_1 = _ram_ext_R0_data[95:64];
  assign io_deq_bits_instructions_2 = _ram_ext_R0_data[127:96];
  assign io_deq_bits_instructions_3 = _ram_ext_R0_data[159:128];
  assign io_deq_bits_valid_bits_0 = _ram_ext_R0_data[160];
  assign io_deq_bits_valid_bits_1 = _ram_ext_R0_data[161];
  assign io_deq_bits_valid_bits_2 = _ram_ext_R0_data[162];
  assign io_deq_bits_valid_bits_3 = _ram_ext_R0_data[163];
endmodule

module Q(
  input         clock,
                reset,
  input  [31:0] io_data_in_fetch_PC,
                io_data_in_instructions_0,
                io_data_in_instructions_1,
                io_data_in_instructions_2,
                io_data_in_instructions_3,
  input         io_data_in_valid_bits_0,
                io_data_in_valid_bits_1,
                io_data_in_valid_bits_2,
                io_data_in_valid_bits_3,
                io_wr_en,
                io_rd_en,
                io_clear,
  output [31:0] io_data_out_fetch_PC,
                io_data_out_instructions_0,
                io_data_out_instructions_1,
                io_data_out_instructions_2,
                io_data_out_instructions_3,
  output        io_data_out_valid_bits_0,
                io_data_out_valid_bits_1,
                io_data_out_valid_bits_2,
                io_data_out_valid_bits_3,
                io_empty
);

  wire _queue_io_deq_valid;
  Queue16_fetch_packet queue (
    .clock                      (clock),
    .reset                      (io_clear | reset),
    .io_enq_valid               (io_wr_en),
    .io_enq_bits_fetch_PC       (io_data_in_fetch_PC),
    .io_enq_bits_instructions_0 (io_data_in_instructions_0),
    .io_enq_bits_instructions_1 (io_data_in_instructions_1),
    .io_enq_bits_instructions_2 (io_data_in_instructions_2),
    .io_enq_bits_instructions_3 (io_data_in_instructions_3),
    .io_enq_bits_valid_bits_0   (io_data_in_valid_bits_0),
    .io_enq_bits_valid_bits_1   (io_data_in_valid_bits_1),
    .io_enq_bits_valid_bits_2   (io_data_in_valid_bits_2),
    .io_enq_bits_valid_bits_3   (io_data_in_valid_bits_3),
    .io_deq_ready               (io_rd_en),
    .io_deq_valid               (_queue_io_deq_valid),
    .io_deq_bits_fetch_PC       (io_data_out_fetch_PC),
    .io_deq_bits_instructions_0 (io_data_out_instructions_0),
    .io_deq_bits_instructions_1 (io_data_out_instructions_1),
    .io_deq_bits_instructions_2 (io_data_out_instructions_2),
    .io_deq_bits_instructions_3 (io_data_out_instructions_3),
    .io_deq_bits_valid_bits_0   (io_data_out_valid_bits_0),
    .io_deq_bits_valid_bits_1   (io_data_out_valid_bits_1),
    .io_deq_bits_valid_bits_2   (io_data_out_valid_bits_2),
    .io_deq_bits_valid_bits_3   (io_data_out_valid_bits_3)
  );
  assign io_empty = ~_queue_io_deq_valid;
endmodule

// VCS coverage exclude_file
module ram_16x32(
  input  [3:0]  R0_addr,
  input         R0_en,
                R0_clk,
  output [31:0] R0_data,
  input  [3:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [31:0] W0_data
);

  reg [31:0] Memory[0:15];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 32'bx;
endmodule

module Queue16_UInt32(
  input         clock,
                reset,
  output        io_enq_ready,
  input         io_enq_valid,
  input  [31:0] io_enq_bits,
  input         io_deq_ready,
  output        io_deq_valid,
  output [31:0] io_deq_bits
);

  reg  [3:0] enq_ptr_value;
  reg  [3:0] deq_ptr_value;
  reg        maybe_full;
  wire       ptr_match = enq_ptr_value == deq_ptr_value;
  wire       empty = ptr_match & ~maybe_full;
  wire       full = ptr_match & maybe_full;
  wire       do_enq = ~full & io_enq_valid;
  always @(posedge clock) begin
    if (reset) begin
      enq_ptr_value <= 4'h0;
      deq_ptr_value <= 4'h0;
      maybe_full <= 1'h0;
    end
    else begin
      automatic logic do_deq = io_deq_ready & ~empty;
      if (do_enq)
        enq_ptr_value <= enq_ptr_value + 4'h1;
      if (do_deq)
        deq_ptr_value <= deq_ptr_value + 4'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge)
  ram_16x32 ram_ext (
    .R0_addr (deq_ptr_value),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (io_deq_bits),
    .W0_addr (enq_ptr_value),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data (io_enq_bits)
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
endmodule

module Q_1(
  input         clock,
                reset,
  input  [31:0] io_data_in,
  input         io_wr_en,
                io_rd_en,
                io_clear,
  output [31:0] io_data_out,
  output        io_full,
                io_empty
);

  wire _queue_io_enq_ready;
  wire _queue_io_deq_valid;
  Queue16_UInt32 queue (
    .clock        (clock),
    .reset        (io_clear | reset),
    .io_enq_ready (_queue_io_enq_ready),
    .io_enq_valid (io_wr_en),
    .io_enq_bits  (io_data_in),
    .io_deq_ready (io_rd_en),
    .io_deq_valid (_queue_io_deq_valid),
    .io_deq_bits  (io_data_out)
  );
  assign io_full = ~_queue_io_enq_ready;
  assign io_empty = ~_queue_io_deq_valid;
endmodule

// VCS coverage exclude_file
module ram_16x53(
  input  [3:0]  R0_addr,
  input         R0_en,
                R0_clk,
  output [52:0] R0_data,
  input  [3:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [52:0] W0_data
);

  reg [52:0] Memory[0:15];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 53'bx;
endmodule

module Queue16_prediction(
  input         clock,
                reset,
                io_enq_valid,
                io_enq_bits_hit,
  input  [31:0] io_enq_bits_target,
  input  [1:0]  io_enq_bits_br_type,
  input  [3:0]  io_enq_bits_br_mask,
  input  [15:0] io_enq_bits_GHR,
  input         io_enq_bits_T_NT,
                io_deq_ready,
  output        io_deq_valid,
                io_deq_bits_hit,
  output [31:0] io_deq_bits_target,
  output [3:0]  io_deq_bits_br_mask,
  output [15:0] io_deq_bits_GHR
);

  wire        io_enq_ready;
  wire [52:0] _ram_ext_R0_data;
  reg  [3:0]  enq_ptr_value;
  reg  [3:0]  deq_ptr_value;
  reg         maybe_full;
  wire        ptr_match = enq_ptr_value == deq_ptr_value;
  wire        empty = ptr_match & ~maybe_full;
  wire        do_enq = io_enq_ready & io_enq_valid;
  assign io_enq_ready = ~(ptr_match & maybe_full);
  always @(posedge clock) begin
    if (reset) begin
      enq_ptr_value <= 4'h0;
      deq_ptr_value <= 4'h0;
      maybe_full <= 1'h0;
    end
    else begin
      automatic logic do_deq = io_deq_ready & ~empty;
      if (do_enq)
        enq_ptr_value <= enq_ptr_value + 4'h1;
      if (do_deq)
        deq_ptr_value <= deq_ptr_value + 4'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge)
  ram_16x53 ram_ext (
    .R0_addr (deq_ptr_value),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (enq_ptr_value),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({io_enq_bits_GHR, io_enq_bits_br_mask, io_enq_bits_target, io_enq_bits_hit})
  );
  assign io_deq_valid = ~empty;
  assign io_deq_bits_hit = _ram_ext_R0_data[0];
  assign io_deq_bits_target = _ram_ext_R0_data[32:1];
  assign io_deq_bits_br_mask = _ram_ext_R0_data[36:33];
  assign io_deq_bits_GHR = _ram_ext_R0_data[52:37];
endmodule

module Q_2(
  input         clock,
                reset,
                io_data_in_hit,
  input  [31:0] io_data_in_target,
  input  [1:0]  io_data_in_br_type,
  input  [3:0]  io_data_in_br_mask,
  input  [15:0] io_data_in_GHR,
  input         io_data_in_T_NT,
                io_wr_en,
                io_rd_en,
                io_clear,
  output        io_data_out_hit,
  output [31:0] io_data_out_target,
  output [3:0]  io_data_out_br_mask,
  output [15:0] io_data_out_GHR,
  output        io_empty
);

  wire _queue_io_deq_valid;
  Queue16_prediction queue (
    .clock               (clock),
    .reset               (io_clear | reset),
    .io_enq_valid        (io_wr_en),
    .io_enq_bits_hit     (io_data_in_hit),
    .io_enq_bits_target  (io_data_in_target),
    .io_enq_bits_br_type (io_data_in_br_type),
    .io_enq_bits_br_mask (io_data_in_br_mask),
    .io_enq_bits_GHR     (io_data_in_GHR),
    .io_enq_bits_T_NT    (io_data_in_T_NT),
    .io_deq_ready        (io_rd_en),
    .io_deq_valid        (_queue_io_deq_valid),
    .io_deq_bits_hit     (io_data_out_hit),
    .io_deq_bits_target  (io_data_out_target),
    .io_deq_bits_br_mask (io_data_out_br_mask),
    .io_deq_bits_GHR     (io_data_out_GHR)
  );
  assign io_empty = ~_queue_io_deq_valid;
endmodule

module Frontend(
  input          clock,
                 reset,
  output         io_misprediction_PC_ready,
  input          io_misprediction_PC_valid,
  input  [31:0]  io_misprediction_PC_bits,
  output         io_exception_PC_ready,
  input          io_exception_PC_valid,
  input  [31:0]  io_exception_PC_bits,
  output         io_dram_data_ready,
  input          io_dram_data_valid,
  input  [255:0] io_dram_data_bits,
  output         io_commit_ready,
  input          io_commit_valid,
  input  [31:0]  io_commit_bits_PC,
  input  [15:0]  io_commit_bits_GHR,
  input          io_commit_bits_T_NT,
  input  [31:0]  io_commit_bits_target,
  input  [1:0]   io_commit_bits_br_type,
  input  [3:0]   io_commit_bits_br_mask,
  input          io_commit_bits_misprediction,
  input  [6:0]   io_commit_bits_TOS,
                 io_commit_bits_NEXT,
  input  [31:0]  io_commit_bits_misprediction_PC,
  input          io_cache_addr_ready,
  output         io_cache_addr_valid,
  output [31:0]  io_cache_addr_bits,
  input          io_fetch_packet_ready,
  output         io_fetch_packet_valid,
  output [31:0]  io_fetch_packet_bits_fetch_PC,
                 io_fetch_packet_bits_instructions_0,
                 io_fetch_packet_bits_instructions_1,
                 io_fetch_packet_bits_instructions_2,
                 io_fetch_packet_bits_instructions_3,
  output         io_fetch_packet_bits_valid_bits_0,
                 io_fetch_packet_bits_valid_bits_1,
                 io_fetch_packet_bits_valid_bits_2,
                 io_fetch_packet_bits_valid_bits_3
);

  wire        _BTB_Q_io_data_out_hit;
  wire [31:0] _BTB_Q_io_data_out_target;
  wire [3:0]  _BTB_Q_io_data_out_br_mask;
  wire [15:0] _BTB_Q_io_data_out_GHR;
  wire        _BTB_Q_io_empty;
  wire [31:0] _PC_Q_io_data_out;
  wire        _PC_Q_io_empty;
  wire [31:0] _instruction_Q_io_data_out_fetch_PC;
  wire [31:0] _instruction_Q_io_data_out_instructions_0;
  wire [31:0] _instruction_Q_io_data_out_instructions_1;
  wire [31:0] _instruction_Q_io_data_out_instructions_2;
  wire [31:0] _instruction_Q_io_data_out_instructions_3;
  wire        _instruction_Q_io_data_out_valid_bits_0;
  wire        _instruction_Q_io_data_out_valid_bits_1;
  wire        _instruction_Q_io_data_out_valid_bits_2;
  wire        _instruction_Q_io_data_out_valid_bits_3;
  wire        _instruction_Q_io_empty;
  wire        _PC_gen_io_PC_next_valid;
  wire [31:0] _PC_gen_io_PC_next_bits;
  wire        _predecoder_io_prediction_ready;
  wire        _predecoder_io_fetch_packet_ready;
  wire        _predecoder_io_revert_valid;
  wire [15:0] _predecoder_io_revert_bits_GHR;
  wire [31:0] _predecoder_io_revert_bits_PC;
  wire [31:0] _predecoder_io_RAS_update_call_addr;
  wire        _predecoder_io_RAS_update_call;
  wire        _predecoder_io_RAS_update_ret;
  wire [31:0] _bp_io_RAS_read_ret_addr;
  wire        _bp_io_prediction_valid;
  wire        _bp_io_prediction_bits_hit;
  wire [31:0] _bp_io_prediction_bits_target;
  wire [1:0]  _bp_io_prediction_bits_br_type;
  wire [3:0]  _bp_io_prediction_bits_br_mask;
  wire [15:0] _bp_io_prediction_bits_GHR;
  wire        _bp_io_prediction_bits_T_NT;
  wire        _instruction_cache_io_cpu_addr_ready;
  wire        _instruction_cache_io_cache_data_valid;
  wire [31:0] _instruction_cache_io_cache_data_bits_fetch_PC;
  wire [31:0] _instruction_cache_io_cache_data_bits_instructions_0;
  wire [31:0] _instruction_cache_io_cache_data_bits_instructions_1;
  wire [31:0] _instruction_cache_io_cache_data_bits_instructions_2;
  wire [31:0] _instruction_cache_io_cache_data_bits_instructions_3;
  wire        _instruction_cache_io_cache_data_bits_valid_bits_0;
  wire        _instruction_cache_io_cache_data_bits_valid_bits_1;
  wire        _instruction_cache_io_cache_data_bits_valid_bits_2;
  wire        _instruction_cache_io_cache_data_bits_valid_bits_3;
  wire        clear = io_commit_bits_misprediction | _predecoder_io_revert_valid;
  L1_instruction_cache instruction_cache (
    .clock                             (clock),
    .reset                             (reset),
    .io_cpu_addr_ready                 (_instruction_cache_io_cpu_addr_ready),
    .io_cpu_addr_valid                 (~_PC_Q_io_empty),
    .io_cpu_addr_bits                  (_PC_Q_io_data_out),
    .io_dram_data_ready                (io_dram_data_ready),
    .io_dram_data_valid                (io_dram_data_valid),
    .io_dram_data_bits                 (io_dram_data_bits),
    .io_kill                           (clear),
    .io_cache_data_valid               (_instruction_cache_io_cache_data_valid),
    .io_cache_data_bits_fetch_PC       (_instruction_cache_io_cache_data_bits_fetch_PC),
    .io_cache_data_bits_instructions_0
      (_instruction_cache_io_cache_data_bits_instructions_0),
    .io_cache_data_bits_instructions_1
      (_instruction_cache_io_cache_data_bits_instructions_1),
    .io_cache_data_bits_instructions_2
      (_instruction_cache_io_cache_data_bits_instructions_2),
    .io_cache_data_bits_instructions_3
      (_instruction_cache_io_cache_data_bits_instructions_3),
    .io_cache_data_bits_valid_bits_0
      (_instruction_cache_io_cache_data_bits_valid_bits_0),
    .io_cache_data_bits_valid_bits_1
      (_instruction_cache_io_cache_data_bits_valid_bits_1),
    .io_cache_data_bits_valid_bits_2
      (_instruction_cache_io_cache_data_bits_valid_bits_2),
    .io_cache_data_bits_valid_bits_3
      (_instruction_cache_io_cache_data_bits_valid_bits_3),
    .io_cache_addr_ready               (io_cache_addr_ready),
    .io_cache_addr_valid               (io_cache_addr_valid),
    .io_cache_addr_bits                (io_cache_addr_bits)
  );
  BP bp (
    .clock                        (clock),
    .reset                        (reset),
    .io_predict_valid             (_PC_gen_io_PC_next_valid),
    .io_predict_bits              (_PC_gen_io_PC_next_bits),
    .io_commit_valid              (io_commit_valid),
    .io_commit_bits_PC            (io_commit_bits_PC),
    .io_commit_bits_GHR           (io_commit_bits_GHR),
    .io_commit_bits_T_NT          (io_commit_bits_T_NT),
    .io_commit_bits_target        (io_commit_bits_target),
    .io_commit_bits_br_type       (io_commit_bits_br_type),
    .io_commit_bits_br_mask       (io_commit_bits_br_mask),
    .io_commit_bits_misprediction (io_commit_bits_misprediction),
    .io_commit_bits_TOS           (io_commit_bits_TOS),
    .io_commit_bits_NEXT          (io_commit_bits_NEXT),
    .io_RAS_update_call_addr      (_predecoder_io_RAS_update_call_addr),
    .io_RAS_update_call           (_predecoder_io_RAS_update_call),
    .io_RAS_update_ret            (_predecoder_io_RAS_update_ret),
    .io_RAS_read_ret_addr         (_bp_io_RAS_read_ret_addr),
    .io_revert_valid              (_predecoder_io_revert_valid),
    .io_revert_bits_GHR           (_predecoder_io_revert_bits_GHR),
    .io_prediction_valid          (_bp_io_prediction_valid),
    .io_prediction_bits_hit       (_bp_io_prediction_bits_hit),
    .io_prediction_bits_target    (_bp_io_prediction_bits_target),
    .io_prediction_bits_br_type   (_bp_io_prediction_bits_br_type),
    .io_prediction_bits_br_mask   (_bp_io_prediction_bits_br_mask),
    .io_prediction_bits_GHR       (_bp_io_prediction_bits_GHR),
    .io_prediction_bits_T_NT      (_bp_io_prediction_bits_T_NT)
  );
  decode_validate predecoder (
    .clock                                     (clock),
    .reset                                     (reset),
    .io_prediction_ready                       (_predecoder_io_prediction_ready),
    .io_prediction_valid                       (~_BTB_Q_io_empty),
    .io_prediction_bits_hit                    (_BTB_Q_io_data_out_hit),
    .io_prediction_bits_target                 (_BTB_Q_io_data_out_target),
    .io_prediction_bits_br_mask                (_BTB_Q_io_data_out_br_mask),
    .io_prediction_bits_GHR                    (_BTB_Q_io_data_out_GHR),
    .io_fetch_packet_ready                     (_predecoder_io_fetch_packet_ready),
    .io_fetch_packet_valid                     (~_instruction_Q_io_empty),
    .io_fetch_packet_bits_fetch_PC             (_instruction_Q_io_data_out_fetch_PC),
    .io_fetch_packet_bits_instructions_0
      (_instruction_Q_io_data_out_instructions_0),
    .io_fetch_packet_bits_instructions_1
      (_instruction_Q_io_data_out_instructions_1),
    .io_fetch_packet_bits_instructions_2
      (_instruction_Q_io_data_out_instructions_2),
    .io_fetch_packet_bits_instructions_3
      (_instruction_Q_io_data_out_instructions_3),
    .io_fetch_packet_bits_valid_bits_0         (_instruction_Q_io_data_out_valid_bits_0),
    .io_fetch_packet_bits_valid_bits_1         (_instruction_Q_io_data_out_valid_bits_1),
    .io_fetch_packet_bits_valid_bits_2         (_instruction_Q_io_data_out_valid_bits_2),
    .io_fetch_packet_bits_valid_bits_3         (_instruction_Q_io_data_out_valid_bits_3),
    .io_RAS_read_ret_addr                      (_bp_io_RAS_read_ret_addr),
    .io_revert_valid                           (_predecoder_io_revert_valid),
    .io_revert_bits_GHR                        (_predecoder_io_revert_bits_GHR),
    .io_revert_bits_PC                         (_predecoder_io_revert_bits_PC),
    .io_final_fetch_packet_ready               (io_fetch_packet_ready),
    .io_final_fetch_packet_valid               (io_fetch_packet_valid),
    .io_final_fetch_packet_bits_fetch_PC       (io_fetch_packet_bits_fetch_PC),
    .io_final_fetch_packet_bits_instructions_0 (io_fetch_packet_bits_instructions_0),
    .io_final_fetch_packet_bits_instructions_1 (io_fetch_packet_bits_instructions_1),
    .io_final_fetch_packet_bits_instructions_2 (io_fetch_packet_bits_instructions_2),
    .io_final_fetch_packet_bits_instructions_3 (io_fetch_packet_bits_instructions_3),
    .io_final_fetch_packet_bits_valid_bits_0   (io_fetch_packet_bits_valid_bits_0),
    .io_final_fetch_packet_bits_valid_bits_1   (io_fetch_packet_bits_valid_bits_1),
    .io_final_fetch_packet_bits_valid_bits_2   (io_fetch_packet_bits_valid_bits_2),
    .io_final_fetch_packet_bits_valid_bits_3   (io_fetch_packet_bits_valid_bits_3),
    .io_RAS_update_call_addr                   (_predecoder_io_RAS_update_call_addr),
    .io_RAS_update_call                        (_predecoder_io_RAS_update_call),
    .io_RAS_update_ret                         (_predecoder_io_RAS_update_ret)
  );
  PC_arbit PC_gen (
    .clock                           (clock),
    .reset                           (reset),
    .io_commit_valid                 (io_commit_valid),
    .io_commit_bits_misprediction    (io_commit_bits_misprediction),
    .io_commit_bits_misprediction_PC (io_commit_bits_misprediction_PC),
    .io_prediction_valid             (_bp_io_prediction_valid),
    .io_prediction_bits_hit          (_bp_io_prediction_bits_hit),
    .io_prediction_bits_target       (_bp_io_prediction_bits_target),
    .io_prediction_bits_br_type      (_bp_io_prediction_bits_br_type),
    .io_revert_valid                 (_predecoder_io_revert_valid),
    .io_revert_bits_PC               (_predecoder_io_revert_bits_PC),
    .io_RAS_read_ret_addr            (_bp_io_RAS_read_ret_addr),
    .io_PC_next_valid                (_PC_gen_io_PC_next_valid),
    .io_PC_next_bits                 (_PC_gen_io_PC_next_bits)
  );
  Q instruction_Q (
    .clock                      (clock),
    .reset                      (reset),
    .io_data_in_fetch_PC        (_instruction_cache_io_cache_data_bits_fetch_PC),
    .io_data_in_instructions_0  (_instruction_cache_io_cache_data_bits_instructions_0),
    .io_data_in_instructions_1  (_instruction_cache_io_cache_data_bits_instructions_1),
    .io_data_in_instructions_2  (_instruction_cache_io_cache_data_bits_instructions_2),
    .io_data_in_instructions_3  (_instruction_cache_io_cache_data_bits_instructions_3),
    .io_data_in_valid_bits_0    (_instruction_cache_io_cache_data_bits_valid_bits_0),
    .io_data_in_valid_bits_1    (_instruction_cache_io_cache_data_bits_valid_bits_1),
    .io_data_in_valid_bits_2    (_instruction_cache_io_cache_data_bits_valid_bits_2),
    .io_data_in_valid_bits_3    (_instruction_cache_io_cache_data_bits_valid_bits_3),
    .io_wr_en                   (_instruction_cache_io_cache_data_valid),
    .io_rd_en                   (~_BTB_Q_io_empty & _predecoder_io_fetch_packet_ready),
    .io_clear                   (clear),
    .io_data_out_fetch_PC       (_instruction_Q_io_data_out_fetch_PC),
    .io_data_out_instructions_0 (_instruction_Q_io_data_out_instructions_0),
    .io_data_out_instructions_1 (_instruction_Q_io_data_out_instructions_1),
    .io_data_out_instructions_2 (_instruction_Q_io_data_out_instructions_2),
    .io_data_out_instructions_3 (_instruction_Q_io_data_out_instructions_3),
    .io_data_out_valid_bits_0   (_instruction_Q_io_data_out_valid_bits_0),
    .io_data_out_valid_bits_1   (_instruction_Q_io_data_out_valid_bits_1),
    .io_data_out_valid_bits_2   (_instruction_Q_io_data_out_valid_bits_2),
    .io_data_out_valid_bits_3   (_instruction_Q_io_data_out_valid_bits_3),
    .io_empty                   (_instruction_Q_io_empty)
  );
  Q_1 PC_Q (
    .clock       (clock),
    .reset       (reset),
    .io_data_in  (_PC_gen_io_PC_next_bits),
    .io_wr_en    (_PC_gen_io_PC_next_valid),
    .io_rd_en    (_instruction_cache_io_cpu_addr_ready),
    .io_clear    (clear),
    .io_data_out (_PC_Q_io_data_out),
    .io_full     (/* unused */),
    .io_empty    (_PC_Q_io_empty)
  );
  Q_2 BTB_Q (
    .clock               (clock),
    .reset               (reset),
    .io_data_in_hit      (_bp_io_prediction_bits_hit),
    .io_data_in_target   (_bp_io_prediction_bits_target),
    .io_data_in_br_type  (_bp_io_prediction_bits_br_type),
    .io_data_in_br_mask  (_bp_io_prediction_bits_br_mask),
    .io_data_in_GHR      (_bp_io_prediction_bits_GHR),
    .io_data_in_T_NT     (_bp_io_prediction_bits_T_NT),
    .io_wr_en            (_bp_io_prediction_valid),
    .io_rd_en            (~_instruction_Q_io_empty & _predecoder_io_prediction_ready),
    .io_clear            (clear),
    .io_data_out_hit     (_BTB_Q_io_data_out_hit),
    .io_data_out_target  (_BTB_Q_io_data_out_target),
    .io_data_out_br_mask (_BTB_Q_io_data_out_br_mask),
    .io_data_out_GHR     (_BTB_Q_io_data_out_GHR),
    .io_empty            (_BTB_Q_io_empty)
  );
  assign io_misprediction_PC_ready = 1'h1;
  assign io_exception_PC_ready = 1'h1;
  assign io_commit_ready = 1'h1;
endmodule

