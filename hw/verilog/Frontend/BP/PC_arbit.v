// Generated by CIRCT firtool-1.62.0
module PC_arbit(
  input         clock,
                reset,
  output        io_commit_ready,
  input         io_commit_valid,
  input  [31:0] io_commit_bits_PC,
  input  [15:0] io_commit_bits_GHR,
  input         io_commit_bits_T_NT,
  input  [31:0] io_commit_bits_target,
  input  [1:0]  io_commit_bits_br_type,
  input  [3:0]  io_commit_bits_br_mask,
  input         io_commit_bits_misprediction,
  input  [6:0]  io_commit_bits_TOS,
                io_commit_bits_NEXT,
  input  [31:0] io_commit_bits_misprediction_PC,
  output        io_prediction_ready,
  input         io_prediction_valid,
                io_prediction_bits_hit,
  input  [31:0] io_prediction_bits_target,
  input  [1:0]  io_prediction_bits_br_type,
  input  [3:0]  io_prediction_bits_br_mask,
  input  [15:0] io_prediction_bits_GHR,
  input         io_prediction_bits_T_NT,
  output        io_revert_ready,
  input         io_revert_valid,
  input  [15:0] io_revert_bits_GHR,
  input  [31:0] io_revert_bits_PC,
  input  [6:0]  io_RAS_read_NEXT,
                io_RAS_read_TOS,
  input  [31:0] io_RAS_read_ret_addr,
  input         io_PC_next_ready,
  output        io_PC_next_valid,
  output [31:0] io_PC_next_bits
);

  wire        misprediction;
  reg  [32:0] PC;
  reg  [31:0] correction_address;
  wire        correct_stage_active = misprediction | io_revert_valid;
  assign misprediction = io_commit_valid & io_commit_bits_misprediction;
  wire        is_ret = io_prediction_bits_br_type == 2'h2;
  reg         REG;
  wire [31:0] io_PC_next_bits_0 =
    REG
      ? correction_address
      : io_prediction_valid & io_prediction_bits_hit & ~is_ret & ~correct_stage_active
          ? io_prediction_bits_target
          : is_ret & ~correct_stage_active
              ? io_RAS_read_ret_addr
              : PC[31:0] + {28'h0, 2'h0 - PC[3:2], 2'h0};
  reg         io_PC_next_valid_REG;
  wire        _io_PC_next_valid_T = correct_stage_active | io_PC_next_valid_REG;
  always @(posedge clock) begin
    if (reset) begin
      PC <= 33'h0;
      correction_address <= 32'h0;
    end
    else begin
      if (~_io_PC_next_valid_T)
        PC <= {1'h0, io_PC_next_bits_0};
      if (io_revert_valid)
        correction_address <= io_revert_bits_PC;
      else if (~misprediction)
        correction_address <= io_commit_bits_misprediction_PC;
    end
    REG <= correct_stage_active;
    io_PC_next_valid_REG <= correct_stage_active;
  end // always @(posedge)
  assign io_commit_ready = 1'h1;
  assign io_prediction_ready = 1'h1;
  assign io_revert_ready = 1'h1;
  assign io_PC_next_valid = ~_io_PC_next_valid_T;
  assign io_PC_next_bits = io_PC_next_bits_0;
endmodule

