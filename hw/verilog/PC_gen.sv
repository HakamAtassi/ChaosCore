// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for prints and assertions.

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

module PC_gen(
  input                                                                                                                                                                                                                                                                                                                                                                                                      clock,
                                                                                                                                                                                                                                                                                                                                                                                                             reset,
  input  struct packed {logic valid; struct packed {logic [31:0] fetch_PC; logic T_NT; logic [5:0] ROB_index; logic [2:0] br_type; logic [1:0] fetch_packet_index; logic is_misprediction; logic exception; logic [31:0] expected_PC; logic [15:0] GHR; logic [6:0] TOS; logic [6:0] NEXT; logic [7:0] free_list_front_pointer; logic [3:0][4:0] RDold; logic [3:0][6:0] RD; logic [3:0] RD_valid; } bits; } io_commit,
  input  struct packed {logic valid; struct packed {logic [31:0] PC; } bits; }                                                                                                                                                                                                                                                                                                                               io_revert,
  output                                                                                                                                                                                                                                                                                                                                                                                                     io_prediction_ready,
  input                                                                                                                                                                                                                                                                                                                                                                                                      io_prediction_valid,
  input  struct packed {logic hit; logic [31:0] target; logic [2:0] br_type; logic [15:0] GHR; logic T_NT; }                                                                                                                                                                                                                                                                                                 io_prediction_bits,
  input  struct packed {logic [6:0] NEXT; logic [6:0] TOS; logic [31:0] ret_addr; }                                                                                                                                                                                                                                                                                                                          io_RAS_read,
  input                                                                                                                                                                                                                                                                                                                                                                                                      io_PC_next_ready,
  output                                                                                                                                                                                                                                                                                                                                                                                                     io_PC_next_valid,
  output struct packed {logic [31:0] addr; logic [31:0] wr_data; logic wr_en; }                                                                                                                                                                                                                                                                                                                              io_PC_next_bits
);

  reg  [31:0] PC_reg;
  reg  [31:0] flush_PC_reg;
  wire        is_misprediction = io_commit.valid & io_commit.bits.is_misprediction;
  wire        is_ret = io_prediction_bits.br_type == 3'h4 & io_prediction_valid;
  wire        flushing_event = is_misprediction | io_revert.valid;
  reg         REG;
  wire [31:0] PC_mux =
    io_prediction_bits.hit & io_prediction_valid & ~is_ret
      ? io_prediction_bits.target
      : is_ret ? io_RAS_read.ret_addr : REG ? flush_PC_reg : PC_reg;
  always @(posedge clock) begin
    if (reset) begin
      PC_reg <= 32'h0;
      flush_PC_reg <= 32'h0;
    end
    else begin
      if (io_PC_next_ready & ~flushing_event)
        PC_reg <= PC_mux + {26'h0, 6'h10 - {2'h0, PC_mux[3:0]}};
      flush_PC_reg <=
        is_misprediction
          ? io_commit.bits.fetch_PC
          : io_revert.valid ? io_revert.bits.PC : 32'h0;
    end
    REG <= flushing_event;
  end // always @(posedge)
  assign io_prediction_ready = io_PC_next_ready;
  assign io_PC_next_valid = ~flushing_event;
  assign io_PC_next_bits = '{addr: PC_mux, wr_data: (32'h0), wr_en: (1'h0)};
endmodule

