// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for prints and assertions.

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

module decoder(
  input                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 clock,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        reset,
  output                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                io_instruction_ready,
  input                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 io_instruction_valid,
  input  struct packed {logic [31:0] instruction; logic [3:0] packet_index; logic [5:0] ROB_index; }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    io_instruction_bits,
  input                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 io_decoded_instruction_ready,
  output                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                io_decoded_instruction_valid,
  output struct packed {struct packed {logic RS1_ready; logic RS2_ready; } ready_bits; logic [4:0] RDold; logic [6:0] RD; logic RD_valid; logic [6:0] RS1; logic RS1_valid; logic [6:0] RS2; logic RS2_valid; logic [20:0] IMM; logic [2:0] FUNCT3; logic [1:0] packet_index; logic [5:0] ROB_index; logic [3:0] MOB_index; logic [3:0] FTQ_index; logic [4:0] instructionType; logic [1:0] portID; logic [1:0] RS_type; logic needs_ALU; logic needs_branch_unit; logic needs_CSRs; logic SUBTRACT; logic MULTIPLY; logic IS_IMM; logic [1:0] memory_type; logic [1:0] access_width; } io_decoded_instruction_bits
);

  wire struct packed {logic RS1_ready; logic RS2_ready; } initialReady =
    '{RS1_ready: 1'h0, RS2_ready: 1'h0};
  wire [8:0]      _GEN = {9{io_instruction_bits.instruction[31]}};
  wire [4:0]      instructionType = io_instruction_bits.instruction[6:2];
  wire            _is_MEM_T = instructionType == 5'h0;
  wire            _is_INT_T_1 = instructionType == 5'h4;
  wire            _is_INT_T_11 = instructionType == 5'h5;
  wire            _is_MEM_T_1 = instructionType == 5'h8;
  wire            _is_INT_T = instructionType == 5'hC;
  wire            _is_INT_T_9 = instructionType == 5'hD;
  wire            _is_INT_T_3 = instructionType == 5'h18;
  wire            _is_INT_T_7 = instructionType == 5'h19;
  wire            _is_INT_T_5 = instructionType == 5'h1B;
  wire            _io_decoded_instruction_bits_RD_valid_T_13 = instructionType == 5'h1C;
  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset
          & ~(_is_MEM_T | instructionType == 5'h1 | instructionType == 5'h2
              | instructionType == 5'h3 | _is_INT_T_1 | _is_INT_T_11
              | instructionType == 5'h6 | _is_MEM_T_1 | instructionType == 5'h9
              | instructionType == 5'hA | instructionType == 5'hB | _is_INT_T
              | _is_INT_T_9 | instructionType == 5'hE | instructionType == 5'h10
              | instructionType == 5'h11 | instructionType == 5'h12
              | instructionType == 5'h13 | instructionType == 5'h14
              | instructionType == 5'h16 | _is_INT_T_3 | _is_INT_T_7 | _is_INT_T_5
              | _io_decoded_instruction_bits_RD_valid_T_13
              | instructionType == 5'h1E)) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed: Enum state must be valid, got %d!\n    at decoder.scala:66 assert(valid, \"Enum state must be valid, got %%%%d!\", opcode(6,2))\n",
                 instructionType);
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
  wire            _needs_ALU_T_1 = io_instruction_bits.instruction[31:25] == 7'h20;
  wire            needs_branch_unit = _is_INT_T_3 | _is_INT_T_5 | _is_INT_T_7;
  wire            needs_ALU =
    _is_INT_T & (_needs_ALU_T_1 | io_instruction_bits.instruction[31:25] == 7'h0)
    | _is_INT_T_1 | _is_INT_T_9 | _is_INT_T_11;
  reg  [2:0][1:0] next_ALU_port;
  always @(posedge clock) begin
    if (reset)
      next_ALU_port <= '{2'h2, 2'h1, 2'h0};
    else if (needs_ALU) begin
      next_ALU_port[2'h0 +: 2] <= next_ALU_port[2'h1 +: 2];
      next_ALU_port[2'h2] <= next_ALU_port[2'h0];
    end
  end // always @(posedge)
  assign io_instruction_ready = io_decoded_instruction_ready;
  assign io_decoded_instruction_valid = io_instruction_valid;
  assign io_decoded_instruction_bits =
    '{ready_bits: initialReady,
      RDold: (io_instruction_bits.instruction[11:7]),
      RD: {2'h0, io_instruction_bits.instruction[11:7]},
      RD_valid:
        ((_is_INT_T | _is_INT_T_1 | _is_MEM_T | _is_INT_T_5 | _is_INT_T_7 | _is_INT_T_9
          | _is_INT_T_11 | _io_decoded_instruction_bits_RD_valid_T_13)
         & io_instruction_valid),
      RS1: {2'h0, io_instruction_bits.instruction[19:15]},
      RS1_valid:
        ((_is_INT_T | _is_INT_T_1 | _is_MEM_T | _is_MEM_T_1 | _is_INT_T_7 | _is_INT_T_3)
         & io_instruction_valid),
      RS2: {2'h0, io_instruction_bits.instruction[24:20]},
      RS2_valid: ((_is_INT_T | _is_MEM_T_1 | _is_INT_T_3) & io_instruction_valid),
      IMM:
        (io_instruction_bits.instruction[6:0] == 7'h63
           ? {{9{io_instruction_bits.instruction[31]}},
              io_instruction_bits.instruction[7],
              io_instruction_bits.instruction[30:25],
              io_instruction_bits.instruction[11:8],
              1'h0}
           : io_instruction_bits.instruction[6:0] == 7'h6F
               ? {io_instruction_bits.instruction[31],
                  io_instruction_bits.instruction[19:12],
                  io_instruction_bits.instruction[20],
                  io_instruction_bits.instruction[30:21],
                  1'h0}
               : io_instruction_bits.instruction[6:0] == 7'h13
                 | io_instruction_bits.instruction[6:0] == 7'h3
                 | io_instruction_bits.instruction[6:0] == 7'h67
                   ? {_GEN, io_instruction_bits.instruction[31:20]}
                   : io_instruction_bits.instruction[6:0] == 7'h23
                       ? {_GEN,
                          io_instruction_bits.instruction[31:25],
                          io_instruction_bits.instruction[11:7]}
                       : io_instruction_bits.instruction[6:0] == 7'h17
                         | io_instruction_bits.instruction[6:0] == 7'h37
                           ? {io_instruction_bits.instruction[31],
                              io_instruction_bits.instruction[31:12]}
                           : 21'h0),
      FUNCT3: (io_instruction_bits.instruction[14:12]),
      packet_index: (io_instruction_bits.packet_index[1:0]),
      ROB_index: (6'h0),
      MOB_index: (4'h0),
      FTQ_index: (4'h0),
      instructionType: instructionType,
      portID:
        (needs_ALU
           ? next_ALU_port[2'h0]
           : needs_branch_unit
               ? 2'h0
               : _is_INT_T
                 & (io_instruction_bits.instruction[14:12] == 3'h4
                    | io_instruction_bits.instruction[14:12] == 3'h5
                    | io_instruction_bits.instruction[14:12] == 3'h6
                    | (&(io_instruction_bits.instruction[14:12])))
                 & io_instruction_bits.instruction[25]
                   ? 2'h1
                   : {2{_is_MEM_T_1 | _is_MEM_T}}),
      RS_type:
        (_is_INT_T | _is_INT_T_1 | _is_INT_T_3 | _is_INT_T_5 | _is_INT_T_7 | _is_INT_T_9
         | _is_INT_T_11
           ? 2'h0
           : _is_MEM_T | _is_MEM_T_1 ? 2'h1 : 2'h2),
      needs_ALU: needs_ALU,
      needs_branch_unit: needs_branch_unit,
      needs_CSRs: (1'h0),
      SUBTRACT: ((_is_INT_T | _is_INT_T_1) & _needs_ALU_T_1),
      MULTIPLY: (_is_INT_T & io_instruction_bits.instruction[31:25] == 7'h1),
      IS_IMM:
        (_is_INT_T_1 | _is_INT_T_9 | _is_INT_T_11 | _is_MEM_T_1 | _is_MEM_T | _is_INT_T_3
         | _is_INT_T_5 | _is_INT_T_7),
      memory_type: (_is_MEM_T ? 2'h1 : {_is_MEM_T_1, 1'h0}),
      access_width:
        (io_instruction_bits.instruction[14:12] == 3'h0
           ? 2'h1
           : io_instruction_bits.instruction[14:12] == 3'h1
               ? 2'h2
               : {2{io_instruction_bits.instruction[14:12] == 3'h2}})};
endmodule

